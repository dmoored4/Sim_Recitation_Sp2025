[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Simulations in IE Recitations",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nReading Time\n\n\n\n\n\n\n\n\nApr 21, 2025\n\n\n8 Gas Station Template\n\n\n11 min\n\n\n\n\n\n\n\nApr 21, 2025\n\n\nHW3 Solution\n\n\n6 min\n\n\n\n\n\n\n\nMar 25, 2025\n\n\nHW2 Solution\n\n\n16 min\n\n\n\n\n\n\n\nMar 12, 2025\n\n\nHW1 Solution\n\n\n9 min\n\n\n\n\n\n\n\nMar 5, 2025\n\n\n7 More Complex Queues with Simmer (MVC)\n\n\n8 min\n\n\n\n\n\n\n\nFeb 26, 2025\n\n\n6 Custom Distributions & Reliability (NJT)\n\n\n12 min\n\n\n\n\n\n\n\nFeb 19, 2025\n\n\n5 Queuing using Simmer\n\n\n3 min\n\n\n\n\n\n\n\nFeb 12, 2025\n\n\n4 Check on Learning\n\n\n3 min\n\n\n\n\n\n\n\nFeb 4, 2025\n\n\n3 Queuing and Animations (Amazon Returns)\n\n\n15 min\n\n\n\n\n\n\n\nJan 29, 2025\n\n\n2 Fitting Distributions (Baggage Handling System)\n\n\n9 min\n\n\n\n\n\n\n\nJan 22, 2025\n\n\n1 Simulations Overview (Wind Turbine Repair)\n\n\n18 min\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#questions",
    "href": "solutions/hw3_nb.html#questions",
    "title": "HW3 Solution",
    "section": "2.1 Questions",
    "text": "2.1 Questions\n\nWhat is the probability of finding one or more taxis waiting at the stand?\nDetermine the average number of taxis at the stand.\nWhat is the average number of taxis waiting at the stand?",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#load-packages",
    "href": "solutions/hw3_nb.html#load-packages",
    "title": "HW3 Solution",
    "section": "3.1 Load Packages",
    "text": "3.1 Load Packages\n\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(simmer.plot)",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#problem-data",
    "href": "solutions/hw3_nb.html#problem-data",
    "title": "HW3 Solution",
    "section": "3.2 Problem Data",
    "text": "3.2 Problem Data\nThis information is taken straight from the problem statement.\n\nn_stalls &lt;- 5\nloading_positions &lt;- 1\n\n# function to sample the interarrival time of taxis\ntaxis_arrival &lt;- function(n=1) {\n  rexp(n, rate = 8)\n}\n\ncust_arrival &lt;- function(n=1) {\n  rexp(n, rate = 10)\n}",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#create-model",
    "href": "solutions/hw3_nb.html#create-model",
    "title": "HW3 Solution",
    "section": "3.3 Create Model",
    "text": "3.3 Create Model\nFor when we get more advanced situations, it is best practice to create an empty simulation environment and then add the details\n\n# best practice is to first i\nsim &lt;- simmer(\"taxi stand\")\n\nFirst I’m adding the constrained resource, the number of stalls. Note that I have the number of servers set with capacity = loading_positions and then I am restricting the queue size to be the total number of stalls minus the loading stalls. For this, it simply means 5 stalls - 1 loading stall = 4 stalls behind the loading.\n\nsim |&gt;\n  # this is where people load\n  add_resource(\"stall\",\n               capacity = loading_positions,\n               queue_size = n_stalls - loading_positions)\n\nsimmer environment: taxi stand | now: 0 | next: \n{ Monitor: in memory }\n{ Resource: stall | monitored: TRUE | server status: 0(1) | queue status: 0(4) }\n\n\nThe trajectory is very simple. As mentioned before, note that the “seize, timeout, release” can be accomplished the exact same as visit from simmer.bricks.\n\ntaxi_traj &lt;- trajectory() |&gt;\n  # takes one unit of the stall\n  seize(\"stall\", 1) |&gt;\n  # samples the cust_arrival distribution\n  timeout(cust_arrival) |&gt;\n  release(\"stall\", 1)\n  # note this is the same as:\n  # visit(\"stall, cust_arrival)\n\nsim |&gt;\n  add_generator(\"taxi\", taxi_traj, taxis_arrival) # samples the time between taxi arrivals\n\nsimmer environment: taxi stand | now: 0 | next: 0\n{ Monitor: in memory }\n{ Resource: stall | monitored: TRUE | server status: 0(1) | queue status: 0(4) }\n{ Source: taxi | monitored: 1 | n_generated: 0 }\n\n\nI prefer to always reset the model before running it as shown here:\n\nsim_time &lt;- 72\n\nreset(sim) |&gt; run(sim_time)\n\nsimmer environment: taxi stand | now: 72 | next: 72.0651127564385\n{ Monitor: in memory }\n{ Resource: stall | monitored: TRUE | server status: 0(1) | queue status: 0(4) }\n{ Source: taxi | monitored: 1 | n_generated: 605 }\n\n\nAnd we can get the tables of results as shown here:\n\ntaxistalls &lt;- get_mon_resources(sim)\ntaxis &lt;- get_mon_arrivals(sim)\n\n\nplot(taxistalls, steps = TRUE, items = \"system\")\n\n\n\n\n\n\n\nFigure 1",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#question-1",
    "href": "solutions/hw3_nb.html#question-1",
    "title": "HW3 Solution",
    "section": "4.1 Question 1",
    "text": "4.1 Question 1\nWhat is the probability of finding one or more taxis waiting at the stand?\nIf you open taxistalls you see that we have a pretty constant amount of data. That is there is no big gaps. So we could be lazy and just take the average number of times that taxistalls$system is greater than or equal to one. We use system because that is the number in the server spot and all taxis behind it.\n\nq1lazy &lt;- mean(taxistalls$system &gt;= 1)\n\nThe lazy result indicates there are one or more taxis 86.36 % of the time.\nThis is tempting but dangerous because it doesn’t account for how long the system was in that state. Think if there were only two data points in our simulation, one at 5 seconds and one at 6 seconds. At 5 seconds, there is one taxi in the system and at 6 seconds there is none for a simulation of 72 hours. If you do a simple average, you will determine there are 0.5 taxis in the system. Clearly the average should be essentially zero.\nTwo steps to properly account for this:\n\nCreate a new row in taxistalls representing time 0 with no taxis\n\n\n# create a zero row starting with a copy of the table\nzero_table &lt;- taxistalls[1, ]\n\n# set each value to 0\nzero_table[1, 2:ncol(zero_table)] &lt;- 0\n\n# bind the tibbles together\ntaxistalls &lt;- bind_rows(\n  zero_table,\n  taxistalls\n  # this isn't necessary because I put the zero row first,\n  # but it's easy to make a mistake and better to just sort it again anyway.\n) |&gt; arrange(time) \n\n\nCreate a new column which gives the time between each row and the row after it\n\n\ntaxistalls &lt;- taxistalls |&gt; mutate(\n  # lead takes the value of the next row\n  # coalesce provides a default value for where there is no \"next row\"\n  # that is when we are looking at the last observation before the end of the\n  # simulation\n  duration = coalesce(lead(time), sim_time) - time\n)\n\nNow we can easily get a time waited average. We could do this by getting all the duration of times where the value is one or more, or we could just do it for the case where it is zero and subtract\n\n# we need to have an \"observation\" at time zero where nothing is in the system\ntime_zero_taxis &lt;- sum(taxistalls$duration[taxistalls$system == 0])\n\nproportion_zero &lt;- time_zero_taxis / sim_time\n\nproportion_1_or_more &lt;- 1 - proportion_zero\n\nNow we have the truly correct answer and as it turns out, it is significantly different than the simple average performed above.\nThe true probability of one or more taxis is 76.71 %",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#question-2",
    "href": "solutions/hw3_nb.html#question-2",
    "title": "HW3 Solution",
    "section": "4.2 Question 2",
    "text": "4.2 Question 2\nDetermine the average number of taxis at the stand.\nWe need to do the same time-weighted average as above.\n\navg_taxis &lt;- sum(taxistalls$system * taxistalls$duration) / sim_time\n\nThere are 1.99 taxis in the system on average.",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "solutions/hw3_nb.html#question-3",
    "href": "solutions/hw3_nb.html#question-3",
    "title": "HW3 Solution",
    "section": "4.3 Question 3",
    "text": "4.3 Question 3\nWhat is the average number of taxis waiting at the stand?\nThis question is (intentionally) a bit ambiguous. If you interpret it the same as the above, then that is fine as long as you’ve explained it. The other alternative is wondering how many taxis are in waiting positions 1-4 (i.e. not in the loading zone). In that case, we still do a time waited average.\n\n# now for this interpretation we use the queue\nwaitng_taxis &lt;- sum(taxistalls$queue * taxistalls$duration) / sim_time\n\nThere are 1.22 taxis waiting behind the loading position.",
    "crumbs": [
      "Homework Solutions",
      "Homework 3"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html",
    "href": "recitations/R4_nb.html",
    "title": "#4 Check on Learning",
    "section": "",
    "text": "Homework?\nProject?\nR?\nQuarto?",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html#simulation-concepts",
    "href": "recitations/R4_nb.html#simulation-concepts",
    "title": "#4 Check on Learning",
    "section": "2.1 Simulation Concepts",
    "text": "2.1 Simulation Concepts\n\n2.1.1 Distributions\n\nWhere do distributions come from?\nWhat information can we get from them?\nIf we have a distribution, how do we simulate data with it?\nIf we have data, how do we figure out which distribution it came from?\nWhat is the relationship between a system process and a distribution?\n\n\n\n2.1.2 Simulations\n\nWhy do we do simulations?\nWhat is the most important step in a simulation?\nHow do we do one?",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html#quarto",
    "href": "recitations/R4_nb.html#quarto",
    "title": "#4 Check on Learning",
    "section": "2.2 Quarto",
    "text": "2.2 Quarto\n\nWhy are we using Quarto?\nWhat does Quarto give you?\nHow do you use R and Quarto?",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html#implementation-in-r",
    "href": "recitations/R4_nb.html#implementation-in-r",
    "title": "#4 Check on Learning",
    "section": "2.3 Implementation in R",
    "text": "2.3 Implementation in R\n\nReading and manipulating data\nTidy data vs. Matrix data. Wide-form tidy vs. Long-form tidy\nCreating Plots\nSampling distributions\nFunctions, Loops, control flow, variables\nFitting distributions\nAnimations",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html#timeline",
    "href": "recitations/R4_nb.html#timeline",
    "title": "#4 Check on Learning",
    "section": "3.1 Timeline",
    "text": "3.1 Timeline\n\n\n\n\n\ngantt\n    title Project Timeline - Simulation Course\n    dateFormat  YYYY-MM-DD\n    section Milestones\n    Assigned : milestone, 2025-02-04, 1d\n    Project Proposal : milestone, 2025-02-18, 1d\n    Spring Break : springbreak, 2025-03-15, 9d\n    Report Date : milestone, 2025-03-25, 1d\n    Presentation: milestone, 2025-03-25, 1d\n\n    section Tasks\n    System Modeling : sys_model, 2025-02-04, 2w\n    Analytical Modeling : anlytical_model, 2025-02-10, 3w\n    Modeling in R :  numerical_model, 2025-02-10, 3w\n    Report : 2025-02-28, 2w\n    Presentation : 2025-02-28, 2w\n    Final Submission : 2025-03-25, 1d\n    \n    section Recitations\n    Intro to `simmer` 1: 2025-02-19, 2d\n    Custom Distributions : 2025-02-26, 2d\n    Intro to `simmer` 2: 2025-03-05, 2d\n    Reporting Results* : 2025-03-12, 2d\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWill be recorded and posted to Canvas",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html#process-flow-and-modeling",
    "href": "recitations/R4_nb.html#process-flow-and-modeling",
    "title": "#4 Check on Learning",
    "section": "3.2 Process Flow and Modeling",
    "text": "3.2 Process Flow and Modeling\n\n\n\n\n\ngantt\n    title Restaurant Order Tracking\n    dateFormat  X\n    axisFormat %M min\n    Start : milestone, 0, 0s\n    Food Prep (10-20 min) :prep, 0, 15m  \n    Food Delivery (20-30 min) :delivery, after prep, 30m  \n    Delivered : milestone, after delivery, 0s",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_nb.html#insights",
    "href": "recitations/R4_nb.html#insights",
    "title": "#4 Check on Learning",
    "section": "3.3 Insights",
    "text": "3.3 Insights\n\nThoughts\nQuestions\nConcerns\nClarifications",
    "crumbs": [
      "Tutorials",
      "#4 Check on Learning"
    ]
  },
  {
    "objectID": "recitations/R4_reveal.html#simulation-concepts",
    "href": "recitations/R4_reveal.html#simulation-concepts",
    "title": "#4 Check on Learning",
    "section": "2.1 Simulation Concepts",
    "text": "2.1 Simulation Concepts"
  },
  {
    "objectID": "recitations/R4_reveal.html#quarto",
    "href": "recitations/R4_reveal.html#quarto",
    "title": "#4 Check on Learning",
    "section": "2.2 Quarto",
    "text": "2.2 Quarto\n\nWhy are we using Quarto?\nWhat does Quarto give you?\nHow do you use R and Quarto?"
  },
  {
    "objectID": "recitations/R4_reveal.html#implementation-in-r",
    "href": "recitations/R4_reveal.html#implementation-in-r",
    "title": "#4 Check on Learning",
    "section": "2.3 Implementation in R",
    "text": "2.3 Implementation in R\n\nReading and manipulating data\nTidy data vs. Matrix data. Wide-form tidy vs. Long-form tidy\nCreating Plots\nSampling distributions\nFunctions, Loops, control flow, variables\nFitting distributions\nAnimations"
  },
  {
    "objectID": "recitations/R4_reveal.html#timeline",
    "href": "recitations/R4_reveal.html#timeline",
    "title": "#4 Check on Learning",
    "section": "3.1 Timeline",
    "text": "3.1 Timeline\n\n\n\n\n\ngantt\n    title Project Timeline - Simulation Course\n    dateFormat  YYYY-MM-DD\n    section Milestones\n    Assigned : milestone, 2025-02-04, 1d\n    Project Proposal : milestone, 2025-02-18, 1d\n    Spring Break : springbreak, 2025-03-15, 9d\n    Report Date : milestone, 2025-03-25, 1d\n    Presentation: milestone, 2025-03-25, 1d\n\n    section Tasks\n    System Modeling : sys_model, 2025-02-04, 2w\n    Analytical Modeling : anlytical_model, 2025-02-10, 3w\n    Modeling in R :  numerical_model, 2025-02-10, 3w\n    Report : 2025-02-28, 2w\n    Presentation : 2025-02-28, 2w\n    Final Submission : 2025-03-25, 1d\n    \n    section Recitations\n    Intro to `simmer` 1: 2025-02-19, 2d\n    Custom Distributions : 2025-02-26, 2d\n    Intro to `simmer` 2: 2025-03-05, 2d\n    Reporting Results* : 2025-03-12, 2d\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWill be recorded and posted to Canvas"
  },
  {
    "objectID": "recitations/R4_reveal.html#process-flow-and-modeling",
    "href": "recitations/R4_reveal.html#process-flow-and-modeling",
    "title": "#4 Check on Learning",
    "section": "3.2 Process Flow and Modeling",
    "text": "3.2 Process Flow and Modeling\n\n\n\n\n\ngantt\n    title Restaurant Order Tracking\n    dateFormat  X\n    axisFormat %M min\n    Start : milestone, 0, 0s\n    Food Prep (10-20 min) :prep, 0, 15m  \n    Food Delivery (20-30 min) :delivery, after prep, 30m  \n    Delivered : milestone, after delivery, 0s"
  },
  {
    "objectID": "recitations/R4_reveal.html#insights",
    "href": "recitations/R4_reveal.html#insights",
    "title": "#4 Check on Learning",
    "section": "3.3 Insights",
    "text": "3.3 Insights\n\nThoughts\nQuestions\nConcerns\nClarifications"
  },
  {
    "objectID": "recitations/R7_nb.html#additional-details",
    "href": "recitations/R7_nb.html#additional-details",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "2.1 Additional Details",
    "text": "2.1 Additional Details\n\nAn intern has observed the process over a number of days\nThey have used fitdistrplus to fit several distributions and used BIC to select the best fit distributions for the various processes which are detailed below in Table 1.\n\n\n\n\nTable 1: MVC Process Estiamted Parameters\n\n\n\n\n\n\n\n\n\n\n\n\nProcess\nNumber of Resources\nDistribution\nParameters\n\n\n\n\n\nArrival\nNA\nExponential\n\\(\\hat\\lambda = 2\\ minutes\\)\n\n\n\nCheck-in\n1\nNormal\n\\(\\hat\\mu = 1.5\\ minute\\), \\(\\hat\\sigma = 5\\ seconds\\)\n\n\n\nForm-completion\n12\nNormal\n\\(\\hat\\mu = 2.5\\ minute\\), \\(\\hat\\sigma = 30\\ seconds\\)\n\n\n\nDocument Check\n4\nLogNormal\n\\(\\hat\\mu_L = 1.75\\ minute\\), \\(\\hat\\sigma_L = 30\\ seconds\\)\n\n\n\nPhoto Station\n3\nWeibull\n\\(\\hat{k} = 2.3\\), \\(\\hat\\lambda = 5.1\\ minutes\\)\n\n\n\n\n\n\n\nThe office runs in the morning from 8:00AM to 4:00 PM with staff shifts and lunches staggered to maintain essentially the same resources throughout the day.\nnote: the “hat” such as \\(\\hat\\mu\\) indicates this is the estimated paramter, \\(\\mu\\). This is what the intern obtained from the fitting the distributions.",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#model-approach",
    "href": "recitations/R7_nb.html#model-approach",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "2.2 Model Approach",
    "text": "2.2 Model Approach\n\nDraw a process diagram\nCreate a customer trajectory in simmer\nAdd resources\nrun simulation and examine results",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#loading-packages",
    "href": "recitations/R7_nb.html#loading-packages",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "3.1 Loading Packages",
    "text": "3.1 Loading Packages\n\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(simmer.plot)",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#defining-model-parameters",
    "href": "recitations/R7_nb.html#defining-model-parameters",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "3.2 Defining Model Parameters",
    "text": "3.2 Defining Model Parameters\n\nsimulation_time &lt;- 60 * (16 - 8) # closing minus opening minus lunch\n\ncust_arrival &lt;- function(n=1) {\n  rexp(n=n, rate = 1/2)\n}\n\ncheck_in &lt;- function(n=1) {\n  rnorm(n=n, mean = 1.5, sd = 5/60)\n}\nn_check_in_clerks &lt;- 1\n\nforms &lt;- function(n=1) {\n  rnorm(n=n, mean = 2.5, sd = 30/60)\n}\nn_tables &lt;- 12\n\nform_check &lt;- function(n=1) {\n  rlnorm(n=n, meanlog = 1.75, sdlog = 30/60)\n}\nn_form_clerk &lt;- 4\n\nphoto_station &lt;- function(n=1) {\n  rweibull(n = n, 2.3, scale = 5.1)\n}\nn_photo_clerks &lt;- 3",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#define-simmer-model",
    "href": "recitations/R7_nb.html#define-simmer-model",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "3.3 Define Simmer Model",
    "text": "3.3 Define Simmer Model\n\ncust_traj &lt;- trajectory(\"customer\") |&gt;\n  \n  seize(\"check-in-clerk\", 1) |&gt;\n  timeout(function() check_in(1)) |&gt;\n  release(\"check-in-clerk\") |&gt;\n  \n  # this is from simmer.bricks and is equivalent to above\n  visit(\"table\", forms, 1) |&gt;\n  \n  # I can even omit the \"1\" because that is the default value\n  visit(\"form-clerk\", form_check) |&gt;\n  \n  visit(\"photo-clerk\", photo_station)\n\n\nmvc &lt;- simmer(\"MVC\") |&gt;\n  add_resource(\"check-in-clerk\", n_check_in_clerks) |&gt;\n  add_resource(\"table\", n_tables) |&gt;\n  add_resource(\"form-clerk\", n_form_clerk) |&gt;\n  add_resource(\"photo-clerk\", n_photo_clerks) |&gt;\n  add_generator(\"customer\", cust_traj, cust_arrival)",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#run-the-simulation",
    "href": "recitations/R7_nb.html#run-the-simulation",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "3.4 Run The Simulation",
    "text": "3.4 Run The Simulation\nBelow we simulate this system for one day\n\nmvc |&gt; run(simulation_time)\n\nsimmer environment: MVC | now: 480 | next: 480.869494826871\n{ Monitor: in memory }\n{ Resource: check-in-clerk | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Resource: table | monitored: TRUE | server status: 0(12) | queue status: 0(Inf) }\n{ Resource: form-clerk | monitored: TRUE | server status: 4(4) | queue status: 2(Inf) }\n{ Resource: photo-clerk | monitored: TRUE | server status: 3(3) | queue status: 1(Inf) }\n{ Source: customer | monitored: 1 | n_generated: 232 }",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#examining-results",
    "href": "recitations/R7_nb.html#examining-results",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "3.5 Examining Results",
    "text": "3.5 Examining Results\nAnd we can start to examine the results as before:\n\nresources &lt;- get_mon_resources(mvc)\n\nplot(resources, metric=\"usage\")\n\n\n\n\n\n\n\nFigure 1: Average resource usage over time\n\n\n\n\n\n\nresources &lt;- get_mon_resources(mvc)\n\nplot(resources, metric=\"usage\", steps = TRUE)\n\n\n\n\n\n\n\nFigure 2: Instananeous resource usage over time\n\n\n\n\n\nFigure 1 and Figure 2 show the difference bewteen the average over time and the instantaneous states of the system.\nAnd we can look at some customer perspective things as well such as shown in Figure 3\n\narrivals &lt;- get_mon_arrivals(mvc)\n\nplot(arrivals, metric = \"flow_time\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFigure 3: Cutomer Flow Time",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#replications",
    "href": "recitations/R7_nb.html#replications",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "3.6 Replications",
    "text": "3.6 Replications\nBut this is a single simulation for a single day. What can we really say about the process?\nWe will be better off simulating many days to get a bettery feel for how things typically process here. This is achieved this by using lapply to the simmer model. When we extract the monitored resources and arrivals (with get_mon_resources and get_mon_arrivals, respectively), the tables have kept track of the replication number for us.\n\nmvcs &lt;- lapply(1:10, function(i) {\n  cust_traj &lt;- trajectory(\"customer\") |&gt;\n    visit(\"check-in-clerk\", check_in) |&gt;\n    visit(\"table\", forms) |&gt;\n    visit(\"form-clerk\", form_check) |&gt;\n    visit(\"photo-clerk\", photo_station)\n  \n  mvc &lt;- simmer(\"MVC\") |&gt;\n    add_resource(\"check-in-clerk\", n_check_in_clerks) |&gt;\n    add_resource(\"table\", n_tables) |&gt;\n    add_resource(\"form-clerk\", n_form_clerk) |&gt;\n    add_resource(\"photo-clerk\", n_photo_clerks) |&gt;\n    add_generator(\"customer\", cust_traj, cust_arrival) |&gt;\n    run(simulation_time)\n})\n\nmvcs_arrivals &lt;- get_mon_arrivals(mvcs)\nmvcs_resources &lt;- get_mon_resources(mvcs)\n\nAnd now we can plot the results of the numerous simulations at once.\n\nplot(mvcs_resources, \"photo-clerk\", metric = \"usage\")\n\n\n\n\n\n\n\nFigure 4: Photo clerk resource usage over replications\n\n\n\n\n\nNow we can see what seems to be random across the scenarios and what the trends seems to be. It’s a little difficult to separate the different series, so we can plot just one of them with items =. This is captured by Figure 5 below:\n\nplot(mvcs_resources, \"photo-clerk\", metric = \"usage\", items = \"queue\")\n\n\n\n\n\n\n\nFigure 5: Photo clerk queue only\n\n\n\n\n\nAnd if we wanted to examine all the queues we can achieve that as shown in Figure 6.\n\nplot(mvcs_resources, metric = \"usage\", items = \"queue\")\n\n\n\n\n\n\n\nFigure 6: All resource queues\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nI am getting the figure captions and references by specifying a fig-cap in the code chunk and a label that starts with fig-. I then reference that fig- with @fig- in the body of the document and it links it automatically as shown below:\nAnd if we wanted to examine all the queues we can achieve\nthat as shown in @fig-all-resource-queeus.\n#| output: true\n#| fig-cap: \"All resource queues\"\n#| label: fig-all-resource-queues\n\nplot(mvcs_resources, metric = \"usage\", items = \"queue\")",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#simulation-creater-function",
    "href": "recitations/R7_nb.html#simulation-creater-function",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "4.1 Simulation creater function",
    "text": "4.1 Simulation creater function\n\ncreate_simmer_model &lt;- function(\n    n_check_in_clerks, check_in_time,\n    n_tables, form_completion_time,\n    n_form_clerk, form_check_time,\n    n_photo_clerks, photo_time,\n    cust_arrival, name = \"\") {\n  \n  # Define the customer trajectory\n  cust_traj &lt;- trajectory(\"customer\") |&gt;\n    visit(\"check-in-clerk\", check_in_time) |&gt;\n    visit(\"table\", form_completion_time) |&gt;\n    visit(\"form-clerk\", form_check_time) |&gt;\n    visit(\"photo-clerk\", photo_time)\n  \n  # Create and return the simmer model (not run yet)\n  simmer(name) |&gt;\n    add_resource(\"check-in-clerk\", n_check_in_clerks) |&gt;\n    add_resource(\"table\", n_tables) |&gt;\n    add_resource(\"form-clerk\", n_form_clerk) |&gt;\n    add_resource(\"photo-clerk\", n_photo_clerks) |&gt;\n    add_generator(\"customer\", cust_traj, cust_arrival)\n}",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#replicating-simulation-using-simulation-creator",
    "href": "recitations/R7_nb.html#replicating-simulation-using-simulation-creator",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "4.2 Replicating Simulation using Simulation Creator",
    "text": "4.2 Replicating Simulation using Simulation Creator\n\nmvcs &lt;- lapply(1:25, function(i) {\n  sim &lt;- create_simmer_model(\n    n_check_in_clerks, check_in,\n    n_tables, forms,\n    n_form_clerk, form_check,\n    n_photo_clerks, photo_station,\n    cust_arrival, name = \"MVC\")\n  \n  sim |&gt; run(simulation_time)\n})",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#extract-results",
    "href": "recitations/R7_nb.html#extract-results",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "4.3 Extract Results",
    "text": "4.3 Extract Results\nEverything else works as it did before, we’ve just made everything neater.\n\narrivals_rep &lt;- get_mon_arrivals(mvcs)\nresources_rep &lt;- get_mon_resources(mvcs)",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#arrival-plots",
    "href": "recitations/R7_nb.html#arrival-plots",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "4.4 Arrival Plots",
    "text": "4.4 Arrival Plots\n\nActivity Time\nWaiting Time\nFlow Time\n\n\nActivity Time\n\nplot(arrivals_rep, metric = \"activity_time\")\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\n\n\nWaiting Time\n\nplot(arrivals_rep, metric = \"waiting_time\")\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\n\n\nFlow Time\n\nplot(arrivals_rep, metric = \"flow_time\")\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#resource-plots",
    "href": "recitations/R7_nb.html#resource-plots",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "4.5 Resource Plots",
    "text": "4.5 Resource Plots\n\nUsage\nUtilization\n\n\nUsage\n\nplot(resources_rep, metric = \"usage\")\n\n\n\n\n\n\n\n\n\nplt &lt;- plot(resources_rep, c(\"check-in-clerk\", \"form-clerk\"),  metric = \"usage\", items=\"server\")\n\n#ggsave(\"replicated-resources.png\", plt)\n\n\n\nUtilization\n\nplot(resources_rep, metric = \"utilization\")",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R7_nb.html#further-development",
    "href": "recitations/R7_nb.html#further-development",
    "title": "#7 More Complex Queues with Simmer (MVC)",
    "section": "5.1 Further Development",
    "text": "5.1 Further Development\n\nConsidered a single customer trajectory through the system\nPeople go to the MVC for many other things as well\nCould model each customer trajectory\nCould aggregate all the different customers into a single distribution\nCould model lunch rotation and breaks",
    "crumbs": [
      "Tutorials",
      "#7 More Complex Queues with Simmer (MVC)"
    ]
  },
  {
    "objectID": "recitations/R0_nb.html#me",
    "href": "recitations/R0_nb.html#me",
    "title": "R0: Introductions",
    "section": "Me",
    "text": "Me\n\nDaniel Moore\n2nd Year PhD Student in ISE\nStudy with Dr. Mieth and part of the ROPeS Lab\n\n\n\n\n\n\ngantt\n    title Career Progression Timeline\n    dateFormat YYYY-MM-DD\n    section Professional\n    Engineer Officer (US Army) : p1, 2010-05-22, 2018-09-30\n    Protective Design Consultant (Arup) : p2, 2020-12-30, 2023-08-03\n\n    section Academic\n    BS in Civil Eng. (USMA) : a1, 2006-06-06, 2010-05-22\n    MS Eng. Mngt. (MS&T): a2, 2015-01-01, 2015-09-01\n    MITA (RBS-Newark) : a3, 2018-09-01, 2019-12-31\n    Ph.D in ISE (Rutgers) : a4, 2023-09-01, 2025-01-22\n\n    section Technical Skills\n    Excel: milestone, t0, 2009-09-01, 0d\n    MathCAD: milestone, t1, 2010-05-22, 0d\n    AMPL : milestone, t1, 2015-06-01, 0d\n    Git, Python, JavaScript : milestone, t1, 2019-01-01, 0d\n    LS-DYNA, Julia, Flux : milestone, t3, 2020-01-01, 0d\n    PowerBI : milestone, t4, 2021-01-01, 0d\n    ArcGIS : milestone, t5, 2022-01-01, 0d\n    R: milestone, t6, 2024-01-30, 0d"
  },
  {
    "objectID": "recitations/R0_nb.html#my-simulations-experience",
    "href": "recitations/R0_nb.html#my-simulations-experience",
    "title": "R0: Introductions",
    "section": "My Simulations Experience",
    "text": "My Simulations Experience\n\nArmy: Tabletop Excercises. Higher echelons use advanced wargaming ( MORS)\nBlast Engineer: Structural Blast Resistance\nEngineer Consultant: Pedestrian Movement\nPhD Research: Distributed Energy Resource Power Flexibility"
  },
  {
    "objectID": "recitations/R0_nb.html#you",
    "href": "recitations/R0_nb.html#you",
    "title": "R0: Introductions",
    "section": "You",
    "text": "You\n\nYour name\nWhat drew you to ISE (or this course if you’re not ISE)\nAnything in particular you want to see in the recitation (applications, content, etc.)"
  },
  {
    "objectID": "recitations/R0_nb.html#typical-recitation-plan",
    "href": "recitations/R0_nb.html#typical-recitation-plan",
    "title": "R0: Introductions",
    "section": "Typical Recitation Plan",
    "text": "Typical Recitation Plan\nWe get 1:20 together each week\n\n5 min Recap & Questions\n15 min demo\n45 min collaborative lab\n15 min open time to work"
  },
  {
    "objectID": "recitations/R0_nb.html#additional-assistanceoffice-hourshelp",
    "href": "recitations/R0_nb.html#additional-assistanceoffice-hourshelp",
    "title": "R0: Introductions",
    "section": "Additional Assistance/Office Hours/Help",
    "text": "Additional Assistance/Office Hours/Help\n\nSend me a message on Canvas anytime, I will respond within 1 business day\nOffice hours (just stop by, no appointment needed):\n\nWednesdays: 4:00 PM - 5:30 PM\nWeeks Hall 222 (Zoom if necessary, send me a message on Canvas)\n\nOr by appointment (send me a message on Canvas)"
  },
  {
    "objectID": "recitations/R0_nb.html#recitation-objectives",
    "href": "recitations/R0_nb.html#recitation-objectives",
    "title": "R0: Introductions",
    "section": "Recitation Objectives",
    "text": "Recitation Objectives\n\nYou can simulate complex systems and communicate findings effectively\nYou are competent in an open-source, general-purpose programming language\nYou can produce high-quality technical reports"
  },
  {
    "objectID": "recitations/R0_nb.html#this-is-your-recitation",
    "href": "recitations/R0_nb.html#this-is-your-recitation",
    "title": "R0: Introductions",
    "section": "This is YOUR Recitation",
    "text": "This is YOUR Recitation\n\nGive me feedback if you all need/want something else\nCome prepared ready to engage with the material\nDo not be distracting or take away from your peers’ experience"
  },
  {
    "objectID": "recitations/R6_nb.html#failure-modes",
    "href": "recitations/R6_nb.html#failure-modes",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "2.1 Failure Modes",
    "text": "2.1 Failure Modes\nIt is assumed that the modes of failure are independent. The three failures at this spot are:\n\nContinuous Welded Rail (CWR) failure: The entire Northeast Corridor is a CWR system meaning each rail is welded to the next. The rail welds are considered ok if at most one out of four welds have failed. (The four welds being the two at both ends of both the left and rigth rails). Individual welds have failed more frequently here than most rail sections. An initial estimate is that they fail at exponentially distributed times of four times per year.\nRailroad Ties. Timber railroad ties are used in this area because of the frequent overnight repairs. However they also wear out faster as they are susceptible to rot. The ties are replaced as needed. As a system of ~20 ties per section of rail, it is taken that the ties will degrade to the point of failure at exponentially distributed times with an average of three times per year in this location.\n“Mud-pumping”: This occurs from the vibrations of the train over an area of track which has poor drainage. Over time, the ballast under the tracks gets compressed and pushed away until the rail and ties are “floating” above the ballast as a beam. This failure is progressive once it begins. However, the time between it beginning is not well studied. Data from the field has been collected and recent studies have suggested that the (Generalized Gamma Distribution)[https://en.wikipedia.org/wiki/Generalized_gamma_distribution] might offer an appropriate failure time distribution model.",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#failure-mode-cont.",
    "href": "recitations/R6_nb.html#failure-mode-cont.",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "2.2 Failure Mode (cont.)",
    "text": "2.2 Failure Mode (cont.)\n\nTrack ConnectionsTimber Railroad TiesMud-Pumping\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Bolted Track\n\n\n\n\n\n\n\n\n\n\n\n(b) Continuous Welded Rail\n\n\n\n\n\n\n\nFigure 1: Track Connections\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Timber Railroad Ties",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#load-packages",
    "href": "recitations/R6_nb.html#load-packages",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "3.1 Load Packages",
    "text": "3.1 Load Packages\n\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(fitdistrplus)",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#failure-time-distributions",
    "href": "recitations/R6_nb.html#failure-time-distributions",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "3.2 Failure Time Distributions",
    "text": "3.2 Failure Time Distributions\n\nCWRRailroad TiesMud-Pumping\n\n\n\nEach weld fails at \\(Exp\\sim(4/year)\\)\nWe need the time until how many welds fail?\nHow to model this?\n\n\n\nn_failures &lt;- 2\nlambda_cwr &lt;- 365/4\n\ncwr &lt;- function(n=1) {\n  rgamma(n, n_failures, rate=1/lambda_cwr)\n}\n\n\n\n\n\nThe section of rail has an accepted exponentially distriubted failure times of 3/year\n\n\nlambda_rrt &lt;- 365/3\n\nrrt &lt;- function(n=1) {\n  rexp(n, rate=1/lambda_rrt)\n}\n\n\n\n\ndegenerative failure\nfailures are correlated to significant weather events, but these are also random\nonce a fault begins, it progresses at an accelerated rate to failure\nwe’ve been directed to compare a Generalized Gamma Distribution to other fits\nwe’ll compare it against our trusty Weibull distribution\n\n\n\n\n\nTwo Distributions\nGeneralized Gamma pdf is given by Equation 1:\n\\[\nf(t; \\theta, \\kappa, \\delta) = \\frac{(\\delta/\\theta^\\kappa)t^{\\kappa-1} e^{-(t/\\theta)^\\delta}}{\\Gamma(\\kappa/\\delta)}\n\\tag{1}\\]\n\nScale Parameter: \\(\\theta\\)\nShape Parameter: \\(\\kappa\\)\nPower Parameter: \\(\\delta\\)\n\nAnd Weibull pdf is given by Equation 2:\n\\[\nf(t; k, \\lambda) = \\frac{k}{\\lambda}\\left( \\frac{t}{\\lambda} \\right)^{k-1}\n\\tag{2}\\]\n\nScale parameter: \\(\\lambda\\)\nShape parameter: \\(k\\)",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#obtain-data",
    "href": "recitations/R6_nb.html#obtain-data",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "4.1 Obtain Data",
    "text": "4.1 Obtain Data\n\ncreate a tibble around read_csv function to load the data as a tibble\nplotting a histogram and and a “smoothed” density plot for basic data inspection\n\n\nmp_ft &lt;- tibble(read_csv(\"mud-pumping-failure-times.csv\"))\n\nmp_ft |&gt; ggplot(aes(x = failure_times_days)) +\n  geom_histogram() +\n  labs(\n    x = \"failure time (days)\",\n    y = \"count\"\n  )\n\n\n\n\nMud-pumping Failure Time Histogram\n\n\n\n\n\nmp_ft |&gt; ggplot(aes(x = failure_times_days)) +\n  geom_density() +\n  labs(\n    x = \"failure time (days)\",\n    y = \"likelihood\"\n  )\n\n\n\n\nMud-pumping Failure Time Density",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#implement-method",
    "href": "recitations/R6_nb.html#implement-method",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "4.2 Implement Method",
    "text": "4.2 Implement Method\nDocumentation indicates we need to provide:\n\nprobability density function d&lt;functionname&gt;\nquantile function q&lt;functionname&gt;\ncumulative distribution function p&lt;functionname&gt;\n\nOur function name will be ggamma so we need dggamma, qggamma, pggamma\nMust follow the same argument names as other distributions. For example see the normal distribution functions:\ndnorm(x, mean = 0, sd = 1, log = FALSE)\npnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nqnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)\nrnorm(n, mean = 0, sd = 1)\n\\[\n\\log(f(x) = \\log(\\delta) - \\kappa \\log(\\theta) - \\log \\Gamma\\left(\\frac{\\kappa}{\\delta}\\right) +\n(\\kappa - 1) \\log(x) - \\left(\\frac{x}{\\theta}\\right)^\\delta\n\\]\n\n# Generalized Gamma PDF\n# Generalized Gamma PDF\ndggamma &lt;- function(x, theta, kappa, delta, log = FALSE) {\n  # Handle zero-length input\n  if (length(x) == 0) return(numeric(0))\n  \n  # Compute log-density\n  val &lt;- log(delta) - kappa * log(theta) - lgamma(kappa / delta) + \n         (kappa - 1) * log(x) - (x / theta)^delta\n  \n  if (log) return(val) else return(exp(val))\n}\n\n# Generalized Gamma CDF\npggamma &lt;- function(q, theta, kappa, delta, log.p = FALSE) {\n  # Handle zero-length input\n  if (length(q) == 0) return(numeric(0))\n  \n  # Corrected transformation\n  val &lt;- pgamma((q / theta)^delta, shape = kappa / delta, scale = 1, log.p = log.p)\n  \n  return(val)\n}\n\n# Generalized Gamma Quantile Function\nqggamma &lt;- function(p, theta, kappa, delta) {\n  # Handle zero-length input\n  if (length(p) == 0) return(numeric(0))\n  \n  # Compute quantile\n  out &lt;- theta * (qgamma(p, shape = kappa / delta, scale = 1)^(1 / delta))\n  return(out)\n}",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#fit-the-distributions",
    "href": "recitations/R6_nb.html#fit-the-distributions",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "4.3 Fit the Distributions",
    "text": "4.3 Fit the Distributions\n\ntheta_start &lt;- mean(mp_ft$failure_times_days)  # Scale estimate\nkappa_start &lt;- (mean(mp_ft$failure_times_days)^2) / var(mp_ft$failure_times_days)  # Shape estimate\ndelta_start &lt;- 1  # Start with 1 and optimize\n\n\nf_ggamma &lt;- fitdist(\n  mp_ft$failure_times_days, \"ggamma\",\n  start = list(\n    theta = theta_start,\n    kappa = kappa_start,\n    delta = delta_start)\n  )\n\nWarning in cov2cor(varcovar): diag(V) had non-positive or NA entries; the\nnon-finite result may be dubious\n\n\nWarning in sqrt(diag(varcovar)): NaNs produced\n\nf_weibull &lt;- fitdist(\n  mp_ft$failure_times_days,\n  \"weibull\"\n)\n\nplot.legend &lt;- c(\"Generalized Gamma\", \"Weibull\")",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#plot-results",
    "href": "recitations/R6_nb.html#plot-results",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "4.4 Plot Results",
    "text": "4.4 Plot Results\n\nDensity Comparison\n\ndenscomp(list(f_ggamma, f_weibull), legendtext = plot.legend)\n\n\n\n\nGeneralized Gamma Fit\n\n\n\n\n\n\nQuantile-Quantile Comparison\n\nqqcomp(list(f_ggamma, f_weibull), legendtext = plot.legend)\n\n\n\n\nGeneralized Gamma QQ-Plot\n\n\n\n\n\n\nCDF Comparison\n\ncdfcomp(list(f_ggamma, f_weibull), legendtext = plot.legend)\n\n\n\n\nGeneralized Gamma CDF\n\n\n\n\n\n\nProbability-Probability Comparison\n\nppcomp(list(f_ggamma, f_weibull), legendtext = plot.legend)\n\n\n\n\nGeneralized Gamma PP-Plot",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#select-evaluation-criteron",
    "href": "recitations/R6_nb.html#select-evaluation-criteron",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "4.5 Select Evaluation Criteron",
    "text": "4.5 Select Evaluation Criteron\nThese diagnostic plots are helpful, but we need something more defensible\nVarious criteria found in course notes.\n\nMSE, SSE, Likelihood, AIC, BIC all provided by fitdistrplus.\nPham’s Criteron (PC): Increase slightly the penalty each time adding parameters in the model when there is too small a sample.\n\n\\[\nPC = \\left( \\frac{n-k}{2} \\right) \\log \\left(\\frac{SSE}{n} \\right) + k \\left( \\frac{n-1}{n-k} \\right)\n\\]\n\nPC &lt;- function(SSE, n, k) {\n  ((n-k) / 2) * log(SSE/n) * k * ((n-1) / (n-k))\n}\n\n\nNumber of samples, \\(n\\)\nNumber of parameters, \\(k\\)\nSum of Squared Error, \\(SSE\\)\n\n\nPredicted Density Values\n\n# n is number of observations\nn &lt;- length(mp_ft$failure_times_days)\n# k is number of parameters\nk_ggamma &lt;- length(f_ggamma$estimate)\nk_weibull &lt;- length(f_weibull$estimate)\n\ndens_ggamma_pred &lt;- dggamma(\n  mp_ft$failure_times_days,\n  theta = f_ggamma$estimate[\"theta\"],\n  kappa = f_ggamma$estimate[\"kappa\"],\n  delta = f_ggamma$estimate[\"delta\"]\n)\n\ndens_weibull_pred &lt;- dweibull(\n  mp_ft$failure_times_days,\n  shape = f_weibull$estimate[\"shape\"],\n  scale = f_weibull$estimate[\"scale\"]\n)\n\n\n\nComparison to Emprical Densities\n\n# Compute empirical density\ndens_emp &lt;- density(mp_ft$failure_times_days)\n\n# Interpolate empirical density to match predicted values\nempirical_vals &lt;- approx(dens_emp$x, dens_emp$y, xout = mp_ft$failure_times_days, rule = 2)$y\n\n\n# Compute Sum of Squared Errors (SSE) for generalized gamma\nsse_ggamma &lt;- sum((empirical_vals - dens_ggamma_pred)^2)\nf_ggamma$SSE &lt;- sse_ggamma\n\n# Compute Sum of Squared Errors (SSE) for Weibull\nsse_weibull &lt;- sum((empirical_vals - dens_weibull_pred)^2)\nf_weibull$SSE &lt;- sse_weibull\n\n# Evaluate PC for the two distributions\nf_ggamma$PC &lt;- PC(sse_ggamma, n, k_ggamma)\nf_weibull$PC &lt;- PC(sse_weibull, n, k_weibull)\n\n\nfitted_distributins &lt;- list(f_ggamma, f_weibull)\n\nsummary_table &lt;- sapply(fitted_distributins, function(fit) {\n  c(\n    \"Number of Parameters\" = as.integer(length(fit$estimate)),  # Number of parameters\n    \"Log-Likelihood\" = fit$loglik,                # Log-likelihood\n    \"AIC\" = fit$aic,                              # Akaike Information Criterion\n    \"BIC\" = fit$bic,                              # Bayesian Information Criterion\n    \"SSE\" = fit$SSE,           # Sum of Squared Error\n    \"PC\" = fit$PC            # Pham's Criteron\n  )\n})\n\ncolnames(summary_table) &lt;- c(\"Gen Gamma\", \"Weibull\") \n\nkable(summary_table)\n\n\nGoodness of Fit Measures\n\n\n\nGen Gamma\nWeibull\n\n\n\n\nNumber of Parameters\n3.0000000\n2.0000000\n\n\nLog-Likelihood\n-130.0411499\n-129.8294174\n\n\nAIC\n266.0822998\n263.6588348\n\n\nBIC\n270.9150535\n266.8806706\n\n\nSSE\n0.0011993\n0.0008403\n\n\nPC\n-558.1960808\n-384.9360366\n\n\n\n\n\nBased on these results, we will opt for the Weibull distribution as it has a prefereable AIC, BIC, and SSE while the Log-Likelihoods were basically the same. While Pham’s criteria was better for the Generalized Gamma, we know that the Weibull is just a special case of the Genearlized Gamma and we prefer the simpler model when other metrics give ambiguous options.\n\nmp &lt;- function(n=1) {\n  rweibull(n, shape=f_weibull$estimate[\"shape\"], scale=f_weibull$estimate[\"scale\"])\n}",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#options",
    "href": "recitations/R6_nb.html#options",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "5.1 Options",
    "text": "5.1 Options\n\n\nWhile-loop\nSample batches of failure times\nUse simmer",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#implementation",
    "href": "recitations/R6_nb.html#implementation",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "5.2 Implementation",
    "text": "5.2 Implementation\n\nwe have our distributions\nwe can sample a set of each one and take the 2nd failure time as the system failure time\nputting this in a table we can easily obtain (simulated) empirical results to the questions asked by the boss\n\n\nRunning the Smulation\n\n# number of scenarios\nn &lt;- 10000\n\nrail_sim &lt;- tibble(\n  scenario = 1:n,\n  CWR = cwr(n),\n  RR = rrt(n),\n  MP = mp(n)\n)\n\nrail_sim &lt;- rail_sim |&gt;\n  mutate(\n    # select only the last 3 columns (not \"scenario\")\n    System = apply(rail_sim[,2:4], 1, function(row) {\n      # sort the values\n      sorted_vals &lt;- sort(row, decreasing = TRUE)\n      # select the second largest\n      sorted_vals[2]\n    })\n  )\n\nkable(head(rail_sim))\n\n\n\n\nscenario\nCWR\nRR\nMP\nSystem\n\n\n\n\n1\n120.41610\n295.47187\n63.06154\n120.41610\n\n\n2\n86.99206\n154.98611\n76.85470\n86.99206\n\n\n3\n230.70444\n36.96435\n75.46884\n75.46884\n\n\n4\n301.90744\n84.03693\n79.75009\n84.03693\n\n\n5\n272.77839\n14.85524\n65.51935\n65.51935\n\n\n6\n494.67597\n207.77783\n83.55625\n207.77783\n\n\n\n\n\n\n\nPivot Data For Plotting\n\nrail_sim_long &lt;- rail_sim |&gt; pivot_longer(\n  cols = -scenario,\n  names_to = \"Failure Type\",\n  values_to = \"Failure Time\"\n)\n\nkable(head(rail_sim_long))\n\n\n\n\nscenario\nFailure Type\nFailure Time\n\n\n\n\n1\nCWR\n120.41610\n\n\n1\nRR\n295.47187\n\n\n1\nMP\n63.06154\n\n\n1\nSystem\n120.41610\n\n\n2\nCWR\n86.99206\n\n\n2\nRR\n154.98611\n\n\n\n\n\n\nrail_sim_long |&gt; ggplot(aes(x=`Failure Time`, color=`Failure Type`)) +\n  stat_ecdf()\n\n\n\n\nComponent and System Failure Times",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#required-metrics",
    "href": "recitations/R6_nb.html#required-metrics",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "5.3 Required Metrics",
    "text": "5.3 Required Metrics\n\n# simply averaging the failure time of the system\nmean_sys_ft &lt;- mean(rail_sim$System)\n\n# applying that to 10 years\nnumber_fail_10yrs &lt;- 10*365 / mean_sys_ft\n\n# creating an empricial cumulative distribution function of the system failures\nsys_ecdf &lt;- ecdf(rail_sim$System)\n\n# the probability of a failure being MORE than 180 days is 1 - ecdf(180)\np_6month &lt;- 1 - sys_ecdf(180)\n\nsys_ft_25thpercentile &lt;- quantile(sys_ecdf, .25)\n\nFrom the simulation:\n\nThe average failure time is 100.51 days.\nThis will result in ~37 failures in 10 years.\nThe probability of a failure occurring after more than 6 months is 9.3%.\nThe 25th percentile system failure time is 69.1 days.",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R6_nb.html#reliability-estimation",
    "href": "recitations/R6_nb.html#reliability-estimation",
    "title": "#6 Custom Distributions & Reliability (NJT)",
    "section": "5.4 Reliability Estimation",
    "text": "5.4 Reliability Estimation\n\n\\(F(t)\\) represents the probability of a failure occuring before time \\(t\\).\nReliability \\(R(t)\\) is the probability the system is functioning at time, \\(t\\).\n\n\\[\nR(t) = 1 - F(t)\n\\]\n\n# simply create a function which is 1 - the system ecdf computed at that time\nR_sys &lt;- function(t) {\n  1 - sys_ecdf(t)\n}\n\n# create a table \nsys_rel_table &lt;- tibble(\n  days = 0:(1.5*365),\n  Reliability = R_sys(days)\n)\n\nsys_rel_table |&gt; ggplot(aes(x=days, y=Reliability)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\nThis is the estimated relability for the system\nIt represents that from any given repair time, this is the probability it will be functioning \\(x\\) days from then.",
    "crumbs": [
      "Tutorials",
      "#6 Custom Distributions & Reliability (NJT)"
    ]
  },
  {
    "objectID": "recitations/R5_nb.html#loading-packages",
    "href": "recitations/R5_nb.html#loading-packages",
    "title": "#5 Queuing using Simmer",
    "section": "4.1 Loading Packages",
    "text": "4.1 Loading Packages\n\n# usual suspects\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(fitdistrplus)\n\n# new kid on the block\nlibrary(simmer)\nlibrary(simmer.plot)\nlibrary(simmer.bricks)",
    "crumbs": [
      "Tutorials",
      "#5 Queuing using Simmer"
    ]
  },
  {
    "objectID": "recitations/R5_nb.html#defining-model",
    "href": "recitations/R5_nb.html#defining-model",
    "title": "#5 Queuing using Simmer",
    "section": "4.2 Defining Model",
    "text": "4.2 Defining Model\n\n# all given in minutes\nlambda &lt;- 1/3\nmu &lt;- 1/2\nt_f &lt;- 4*60\n\nRV_arr &lt;- function(n=1) {\n  rexp(n, rate = lambda)\n}\n\nRV_service &lt;- function(n=1) {\n  rexp(n, rate = mu)\n}",
    "crumbs": [
      "Tutorials",
      "#5 Queuing using Simmer"
    ]
  },
  {
    "objectID": "recitations/R5_nb.html#simmer-components",
    "href": "recitations/R5_nb.html#simmer-components",
    "title": "#5 Queuing using Simmer",
    "section": "4.3 Simmer Components",
    "text": "4.3 Simmer Components\n\nEnvironment: The simulation environment, which contains the resources and processes\nTrajectories: The paths that entities take through the simulation, which define the sequence of events that occur\nResources: The resources that are used in the simulation, such as servers, buses, and waiting areas\n\nLet’s break the problem down into components\n\n4.3.1 Customer Trajectory\n\ncust_traj &lt;- trajectory() |&gt;\n  seize(\"clerk\", 1) |&gt;\n  timeout(function() RV_service(1)) |&gt;\n  release(\"clerk\", 1)\n\n\nVery basic trajectory. Customer shows up, gets in line (if necessary), makes a return, and leaves as shown in @plot-customer-trajectory\n\n\nplot(cust_traj)\n\n\nsome bug I’ll investigate and demonstrate next time how to get the plot to appear correctly.\n\n\n\n4.3.2 More complex trajectory\nMore complex plotted trajectory from the docs\n\n\n4.3.3 Instantiating the Simulation Environment\n\nreturn_line &lt;- simmer() |&gt;\n  add_resource(\"clerk\", 1) |&gt;\n  add_generator(\"customer\", cust_traj, function() RV_arr(1))",
    "crumbs": [
      "Tutorials",
      "#5 Queuing using Simmer"
    ]
  },
  {
    "objectID": "recitations/R5_nb.html#running-the-simulation",
    "href": "recitations/R5_nb.html#running-the-simulation",
    "title": "#5 Queuing using Simmer",
    "section": "4.4 Running the Simulation",
    "text": "4.4 Running the Simulation\n\nreturn_line |&gt; run(t_f)\n\nsimmer environment: anonymous | now: 240 | next: 244.828354131011\n{ Monitor: in memory }\n{ Resource: clerk | monitored: TRUE | server status: 0(1) | queue status: 0(Inf) }\n{ Source: customer | monitored: 1 | n_generated: 59 }",
    "crumbs": [
      "Tutorials",
      "#5 Queuing using Simmer"
    ]
  },
  {
    "objectID": "recitations/R5_nb.html#getting-results",
    "href": "recitations/R5_nb.html#getting-results",
    "title": "#5 Queuing using Simmer",
    "section": "4.5 Getting Results",
    "text": "4.5 Getting Results\nget_mon_resources: gets information about the “server” usage get_mon_arrivals: gets information about the “customers”\n\n4.5.1 Resource Visualization\n\nresources &lt;- get_mon_resources(return_line)\n\nkable(head(resources))\n\n\naverages over time:\n\n\nplot(resources, metric = \"usage\")\n\n\n\n\nSystem usage over time\n\n\n\n\n\ninstantaneous usage:\n\n\nplot(resources, metric = \"usage\", steps=TRUE)\n\n\n\n\nSystem usage over time\n\n\n\n\n\nutiliazation of the resources. Not super interesting here due to only one resource\n\n\nplot(resources, metric = \"utilization\")\n\n\n\n\nSystem utilization over time\n\n\n\n\n\nlooking at just the queue\n\n\nplot(resources, metric = \"usage\", items=\"queue\", steps=TRUE)\n\n\n\n\nQueue usage over time\n\n\n\n\n\nplot(resources, metric = \"usage\", items=\"server\", steps=TRUE)\n\n\n\n\n\n\n\n\n\n\n4.5.2 Customer Visualization\n\narrivals &lt;- get_mon_arrivals(return_line)\n\nkable(head(arrivals))\n\n\n\n\n\n\n\n\n\n\n\n\nname\nstart_time\nend_time\nactivity_time\nfinished\nreplication\n\n\n\n\ncustomer0\n0.2800509\n0.8380165\n0.5579656\nTRUE\n1\n\n\ncustomer1\n2.8900381\n2.9416144\n0.0515763\nTRUE\n1\n\n\ncustomer2\n14.6486255\n15.8034746\n1.1548491\nTRUE\n1\n\n\ncustomer3\n25.1743917\n25.2749100\n0.1005183\nTRUE\n1\n\n\ncustomer4\n43.2958968\n43.4317184\n0.1358216\nTRUE\n1\n\n\ncustomer5\n44.0569947\n50.1884576\n6.1314628\nTRUE\n1\n\n\n\n\n\n\nplot(arrivals, metric = \"activity_time\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nActivity time of customers\n\n\n\n\n\nplot(arrivals, metric = \"waiting_time\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nWait time of customers\n\n\n\n\n\nplot(arrivals, metric = \"flow_time\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nFlow time of customers",
    "crumbs": [
      "Tutorials",
      "#5 Queuing using Simmer"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#start-r-studio",
    "href": "recitations/R2_nb.html#start-r-studio",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "1.1 Start R Studio",
    "text": "1.1 Start R Studio",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#load-necessary-packages",
    "href": "recitations/R2_nb.html#load-necessary-packages",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "1.2 Load Necessary Packages",
    "text": "1.2 Load Necessary Packages\n\n\nCode\ninstall.packages(\"tidyverse\")\ninstall.packages(\"knitr\")\ninstall.packages(\"fitdistrplus\")\n\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(fitdistrplus)",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#download-data",
    "href": "recitations/R2_nb.html#download-data",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "1.3 Download Data",
    "text": "1.3 Download Data\n\nAirline Arrival data Bureau of Transportation Statistics\nSimulated Baggage data: https://tinyurl.com/sim-bag-data\n\n\n\nCode\n# Options: \n# data &lt;- read_csv(\"path/to/where/you/downloaded/it\")\n# navigate to the file in your file explorer pane. Click on the file and \"import dataset\"\ndata &lt;- read_csv(\"https://tinyurl.com/sim-bag-data\")\nhead(data)\n\n\n# A tibble: 6 × 5\n  `Flight Number` `Tail Number` `Origin Airport` Arrival            \n  &lt;chr&gt;           &lt;chr&gt;         &lt;chr&gt;            &lt;dttm&gt;             \n1 0208            N804UA        ATL              2024-01-23 22:47:00\n2 0208            N804UA        ATL              2024-01-23 22:47:00\n3 0208            N804UA        ATL              2024-01-23 22:47:00\n4 0208            N804UA        ATL              2024-01-23 22:47:00\n5 0208            N804UA        ATL              2024-01-23 22:47:00\n6 0208            N804UA        ATL              2024-01-23 22:47:00\n# ℹ 1 more variable: bag_completion_time &lt;dttm&gt;",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#visualize-data",
    "href": "recitations/R2_nb.html#visualize-data",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "3.1 Visualize Data",
    "text": "3.1 Visualize Data\n\n\nCode\ndata &lt;- data |&gt; mutate(bag_delivery_time = as.numeric(bag_completion_time - Arrival))\n\ndata |&gt; ggplot(aes(x = bag_delivery_time)) + \n  geom_histogram()",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#fit-distributions-to-data",
    "href": "recitations/R2_nb.html#fit-distributions-to-data",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "3.2 Fit Distributions to Data",
    "text": "3.2 Fit Distributions to Data\n\nuse fitdistrplus to fit various distributions\n\n\n\nCode\nf_norm &lt;- fitdist(data$bag_delivery_time, \"norm\")\nf_ln &lt;- fitdist(data$bag_delivery_time, \"lnorm\")\nf_weibull &lt;- fitdist(data$bag_delivery_time, \"weibull\")\nf_gamma &lt;- fitdist(data$bag_delivery_time, \"gamma\")\n\nplot.legend &lt;- c(\"Normal\", \"LogNormal\", \"Weibull\", \"Gamma\")\n\n\n\nuse plotting functionality to plot a comparison of the data.\n\n\n\nCode\ndenscomp(\n  list(f_norm, f_ln, f_weibull, f_gamma),\n  xlab = \"Bag Delivery Time (min)\",\n  legendtext = plot.legend)",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#compare-to-manual-apporach",
    "href": "recitations/R2_nb.html#compare-to-manual-apporach",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "3.3 Compare to Manual Apporach",
    "text": "3.3 Compare to Manual Apporach\n\nAlternatively, can generate probabilities for each bag arrival time by applying the fitted distributions to the data\n\n\n\nCode\ndata &lt;- data |&gt; mutate(\n  Weibull = dweibull(bag_delivery_time,\n                      shape = f_weibull$estimate[\"shape\"],\n                      scale = f_weibull$estimate[\"scale\"]),\n  Normal = dnorm(bag_delivery_time,\n                      mean = f_norm$estimate[\"mean\"],\n                      sd = f_norm$estimate[\"sd\"]),\n  Gamma = dgamma(bag_delivery_time,\n                      shape = f_gamma$estimate[\"shape\"],\n                      rate = f_gamma$estimate[\"rate\"]),\n  LogNormal = dlnorm(bag_delivery_time,\n                      meanlog = f_ln$estimate[\"meanlog\"],\n                      sdlog = f_ln$estimate[\"sdlog\"]),\n)\n\n\n\nThen can plot these direclty one at a time\n\n\n\nCode\ndata |&gt; ggplot(aes(x = bag_delivery_time)) +\n  geom_line(aes(y = Gamma, color=\"Gamma\", line=\"grey\")) +\n  geom_line(aes(y = Normal, color=\"Normal\")) +\n  geom_line(aes(y = LogNormal, color=\"LogNormal\")) +\n  labs(\n    color = \"Distribution\",\n    x = \"Bag Delivery Time (min)\",\n    y = \"Probability Density\"\n  )\n\n\n\n\n\n\n\n\n\n\nAlternatively, we could transform our tidy data from “wide” to “long” form\n\n\n\nCode\nlong_data &lt;- data |&gt; pivot_longer(\n  cols = c(Gamma, LogNormal, Normal, Weibull),\n  names_to = \"Distribution\",\n  values_to = \"Probability\")\n\n\n\nUsing kable to output a formatted table.\n\n\n\nCode\nkable(head(long_data))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFlight Number\nTail Number\nOrigin Airport\nArrival\nbag_completion_time\nbag_delivery_time\nDistribution\nProbability\n\n\n\n\n0208\nN804UA\nATL\n2024-01-23 17:47:00\n2024-01-23 18:12:48\n25.80000\nGamma\n0.0632560\n\n\n0208\nN804UA\nATL\n2024-01-23 17:47:00\n2024-01-23 18:12:48\n25.80000\nLogNormal\n0.0666378\n\n\n0208\nN804UA\nATL\n2024-01-23 17:47:00\n2024-01-23 18:12:48\n25.80000\nNormal\n0.0566180\n\n\n0208\nN804UA\nATL\n2024-01-23 17:47:00\n2024-01-23 18:12:48\n25.80000\nWeibull\n0.0480593\n\n\n0208\nN804UA\nATL\n2024-01-23 17:47:00\n2024-01-23 18:19:04\n32.06667\nGamma\n0.0687913\n\n\n0208\nN804UA\nATL\n2024-01-23 17:47:00\n2024-01-23 18:19:04\n32.06667\nLogNormal\n0.0661965\n\n\n\n\n\n\nand we can actually plot this much easier\n\n\n\nCode\nggplot() +\n  # Histogram or density plot of `bag_delivery_time`\n  geom_histogram(data = data, aes(x = bag_delivery_time, y = ..density..), \n                 bins = 30, color=\"black\", fill = \"skyblue\", alpha = 0.5) +\n  # Overlay probability density lines from `long_data`\n  geom_line(data = long_data, aes(x = bag_delivery_time, y = Probability, color = Distribution), size=1)\n\n\n\n\n\n\n\n\n\n\nFor relativley simple scenarios, it may be easier to manually plot the data yourself\nAs data and plots become more sophisticated this can be difficult\nI recommend getting familiar with “long” and “wide” data and how to go between the two.",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R2_nb.html#conclusion",
    "href": "recitations/R2_nb.html#conclusion",
    "title": "#2 Fitting Distributions (Baggage Handling System)",
    "section": "3.4 Conclusion",
    "text": "3.4 Conclusion\n\nWhich distribution is the best fit?\nHow do you know?\nDoes the schematic design meet specifications?\n\n\n\nCode\n#| echo: true\n\nfitted_distributins &lt;- list(f_gamma, f_ln, f_norm, f_weibull)\n\n# Extract summary metrics from the fitted distributions\nsummary_table &lt;- sapply(fitted_distributins, function(fit) {\n  c(\n    \"Number of Parameters\" = as.integer(length(fit$estimate)),  # Number of parameters\n    \"Log-Likelihood\" = fit$loglik,                # Log-likelihood\n    \"AIC\" = fit$aic,                              # Akaike Information Criterion\n    \"BIC\" = fit$bic                               # Bayesian Information Criterion\n  )\n})\n\n# Convert to a data frame for readability\n# summary_table &lt;- as.data.frame(summary_table)\n\n# Assign column names based on your distributions\ncolnames(summary_table) &lt;- c(\"Gamma\", \"Log-Normal\", \"Normal\", \"Weibull\")  # Adjust based on distribution names\n\n# View the table\nkable(summary_table)\n\n\n\n\n\n\nGamma\nLog-Normal\nNormal\nWeibull\n\n\n\n\nNumber of Parameters\n2.00\n2.00\n2.00\n2.0\n\n\nLog-Likelihood\n-58690.38\n-58732.54\n-58877.11\n-59819.8\n\n\nAIC\n117384.75\n117469.09\n117758.23\n119643.6\n\n\nBIC\n117400.51\n117484.84\n117773.98\n119659.3",
    "crumbs": [
      "Tutorials",
      "#2 Fitting Distributions (Baggage Handling System)"
    ]
  },
  {
    "objectID": "recitations/R1_reveal.html#development-stack",
    "href": "recitations/R1_reveal.html#development-stack",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "1.1 Development Stack",
    "text": "1.1 Development Stack\n\n\n\\(\\textsf{R}\\): R is a language and environment for statistical computing and graphics. Its predecessor, “S”, was developed by Bell Labs in Murray Hill, NJ.\n\\(\\textsf{RStudio}\\): Used by millions of people weekly, the RStudio integrated development environment (IDE) is a set of tools built to help you be more productive with R and Python.\nQuarto: An open-source scientific and technical publishing system. Analyze. Share. Reproduce. You have a story to tell with data—tell it with Quarto.\nMarkdown. Lightweight language to format plain text."
  },
  {
    "objectID": "recitations/R1_reveal.html#hello-world",
    "href": "recitations/R1_reveal.html#hello-world",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "1.2 Hello, World!",
    "text": "1.2 Hello, World!\n\nStandard test to make sure a programming environment is properly configured\n\n\nprint(\"Hello, World!\")\n\n[1] \"Hello, World!\"\n\n\n\n\n\n\n\n\nTip\n\n\nFor \\(\\textsf{R}\\) tutorials, go to top-right corner of \\(\\textsf{RStudio}\\) and look for the “Tutorial” tab. Follow instructions in the pane."
  },
  {
    "objectID": "recitations/R1_reveal.html#package-management",
    "href": "recitations/R1_reveal.html#package-management",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "1.3 Package Management",
    "text": "1.3 Package Management\n\\(\\textsf{R}\\) is a go-to language for many domains because of its mature packages for many kinds of data analysis. These packages are easily accessible via the Comprehensive R Archive Network (CRAN)\nnote: click on the tabs to see additional content\n\nInstall PackagesLoad Packages\n\n\nThis tells CRAN to find your desired package and download a copy to your working environment.\n\nOption 1: Go to Files Pane (lower right) \\(\\rightarrow\\) Packages tab \\(\\rightarrow\\) Install \\(\\rightarrow\\) &lt;search for your package&gt; \\(\\rightarrow\\) follow prompts in console\nOption 2: In the console pane (lower left), type install.packages(\"&lt;pkg_name&gt;\") \\(\\rightarrow\\) follow prompts\n\n\n\nCode\n# installing packages\ninstall.packages(\"tidyverse\")\ninstall.packages(\"ggExtra\")\n\n\n\n\nThis tells your current R session to read the [downloaded] packages and then you can use them.\n\nOption 1: File Pane \\(\\rightarrow\\) Packages Tab \\(\\rightarrow\\) scroll or search for your package \\(\\rightarrow\\) click the checkbox\nOption 2: In the console or your working file put: library(&lt;pkg_name&gt;).\n\n\n\nCode\n# loading packages\nlibrary(tidyverse)\nlibrary(ggExtra)"
  },
  {
    "objectID": "recitations/R1_reveal.html#wind-turbine-breakdown",
    "href": "recitations/R1_reveal.html#wind-turbine-breakdown",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.1 Wind Turbine Breakdown",
    "text": "2.1 Wind Turbine Breakdown\n\nProblemAnalytical SolutionSimulation Plan\n\n\n\n\nAn offshore wind farm operates 300 turbines. The breakdown rate follows an exponential distribution with a rate of one per 2000 hours of operation. How many breakdowns should be anticipated per year?\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith this information we can simply take the parameter, \\(\\lambda\\), and multiply it by the hours in a year and the total number of turbines to get the expected number of failures in the year.\n\\[\nX \\sim Exp \\left( \\lambda = \\frac{1}{2,000\\ hrs} \\right)\n\\]\n\\[\nf_X(t | \\lambda) = \\lambda e^{-\\lambda t}\n\\]\n\\[\nN = 300\\ turbines \\frac{365\\ days}{year} \\frac{24\\ hrs}{day} \\frac{1\\ breakdown/turbine}{2,000\\ hrs} = 1,314\\ breakdowns/year\n\\]\n\n\nThis is a silly problem to simulate, but we will do it anyway. We have a few options:\n\nSample \\(X\\) to get breakdown times and see how many we get in one year. Then multiply that by 300\nSample \\(X\\) to get breakdown times for each turbine and add them all together\nDo (1) or (2) for \\(N\\) years and then divide the result by \\(N\\). (\\(N\\) could be less than 1. What does that mean?)\nRecognize Exponential gives failure times, Poisson gives failures in a given time. Use that instead"
  },
  {
    "objectID": "recitations/R1_reveal.html#wind-turbine-repair",
    "href": "recitations/R1_reveal.html#wind-turbine-repair",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.2 Wind Turbine Repair",
    "text": "2.2 Wind Turbine Repair\nRepairs are assumed to take 96 hours (the average). How much turbine-down time should be expected per year? How many breakdowns should be anticipated per year?"
  },
  {
    "objectID": "recitations/R1_reveal.html#lognormally-distributed-repair-time",
    "href": "recitations/R1_reveal.html#lognormally-distributed-repair-time",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.3 LogNormally Distributed Repair Time",
    "text": "2.3 LogNormally Distributed Repair Time\n\nMost repairs take about the same amount of time, but some take a long time (think specialty overseas parts etc).\n\n\\[\nY \\sim LogNormal(\\mu, \\sigma^2)\n\\] \\[\nf_Y(t | \\mu, \\sigma) = \\frac{1}{\\sqrt{2\\pi \\sigma t}} \\exp \\left( \\frac{-(log(t)-\\mu)^2}{2\\sigma^2} \\right)\n\\]"
  },
  {
    "objectID": "recitations/R1_reveal.html#collecting-more-simulation-data",
    "href": "recitations/R1_reveal.html#collecting-more-simulation-data",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.4 Collecting more Simulation Data",
    "text": "2.4 Collecting more Simulation Data\nWe want to ask questions about the distribution of failures and repairs. We need to collect more data from the simulation and store it in an easy format for manipuation."
  },
  {
    "objectID": "recitations/R1_nb.html",
    "href": "recitations/R1_nb.html",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "",
    "text": "Develop a motivating example for IE simulation models\nDemonstrate the type of coding complexity that we will build up to during the course\nGauge students’ level of expertise in probability models and programming",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#development-stack",
    "href": "recitations/R1_nb.html#development-stack",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "1.1 Development Stack",
    "text": "1.1 Development Stack\n\n\n\\(\\textsf{R}\\): R is a language and environment for statistical computing and graphics. Its predecessor, “S”, was developed by Bell Labs in Murray Hill, NJ.\n\\(\\textsf{RStudio}\\): Used by millions of people weekly, the RStudio integrated development environment (IDE) is a set of tools built to help you be more productive with R and Python.\nQuarto: An open-source scientific and technical publishing system. Analyze. Share. Reproduce. You have a story to tell with data—tell it with Quarto.\nMarkdown. Lightweight language to format plain text.",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#hello-world",
    "href": "recitations/R1_nb.html#hello-world",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "1.2 Hello, World!",
    "text": "1.2 Hello, World!\n\nStandard test to make sure a programming environment is properly configured\n\n\nprint(\"Hello, World!\")\n\n[1] \"Hello, World!\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor \\(\\textsf{R}\\) tutorials, go to top-right corner of \\(\\textsf{RStudio}\\) and look for the “Tutorial” tab. Follow instructions in the pane.",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#package-management",
    "href": "recitations/R1_nb.html#package-management",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "1.3 Package Management",
    "text": "1.3 Package Management\n\\(\\textsf{R}\\) is a go-to language for many domains because of its mature packages for many kinds of data analysis. These packages are easily accessible via the Comprehensive R Archive Network (CRAN)\nnote: click on the tabs to see additional content\n\nInstall PackagesLoad Packages\n\n\nThis tells CRAN to find your desired package and download a copy to your working environment.\n\nOption 1: Go to Files Pane (lower right) \\(\\rightarrow\\) Packages tab \\(\\rightarrow\\) Install \\(\\rightarrow\\) &lt;search for your package&gt; \\(\\rightarrow\\) follow prompts in console\nOption 2: In the console pane (lower left), type install.packages(\"&lt;pkg_name&gt;\") \\(\\rightarrow\\) follow prompts\n\n\n\nCode\n# installing packages\ninstall.packages(\"tidyverse\")\ninstall.packages(\"ggExtra\")\n\n\n\n\nThis tells your current R session to read the [downloaded] packages and then you can use them.\n\nOption 1: File Pane \\(\\rightarrow\\) Packages Tab \\(\\rightarrow\\) scroll or search for your package \\(\\rightarrow\\) click the checkbox\nOption 2: In the console or your working file put: library(&lt;pkg_name&gt;).\n\n\n\nCode\n# loading packages\nlibrary(tidyverse)\nlibrary(ggExtra)",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#wind-turbine-breakdown",
    "href": "recitations/R1_nb.html#wind-turbine-breakdown",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.1 Wind Turbine Breakdown",
    "text": "2.1 Wind Turbine Breakdown\n\nProblemAnalytical SolutionSimulation Plan\n\n\n\n\nAn offshore wind farm operates 300 turbines. The breakdown rate follows an exponential distribution with a rate of one per 2000 hours of operation. How many breakdowns should be anticipated per year?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith this information we can simply take the parameter, \\(\\lambda\\), and multiply it by the hours in a year and the total number of turbines to get the expected number of failures in the year.\n\\[\nX \\sim Exp \\left( \\lambda = \\frac{1}{2,000\\ hrs} \\right)\n\\]\n\\[\nf_X(t | \\lambda) = \\lambda e^{-\\lambda t}\n\\]\n\\[\nN = 300\\ turbines \\frac{365\\ days}{year} \\frac{24\\ hrs}{day} \\frac{1\\ breakdown/turbine}{2,000\\ hrs} = 1,314\\ breakdowns/year\n\\]\n\n\nThis is a silly problem to simulate, but we will do it anyway. We have a few options:\n\nSample \\(X\\) to get breakdown times and see how many we get in one year. Then multiply that by 300\nSample \\(X\\) to get breakdown times for each turbine and add them all together\nDo (1) or (2) for \\(N\\) years and then divide the result by \\(N\\). (\\(N\\) could be less than 1. What does that mean?)\nRecognize Exponential gives failure times, Poisson gives failures in a given time. Use that instead\n\n\n\n\n\nSimulation Parameters\n\n# I've defined certain \"params\" in the header of the document\nlambda &lt;- 1 / params$breakdown_rate # Breakdown rate (failures per hour)\nN &lt;- params$sim_yrs                 # Total simulation time in years\nK &lt;- params$turbines                # Number of turbines\nyr &lt;- 24 * 365                      # number of hours in a year\n\n# define a RV, X, which will sample the exp dist. when we call X()\nX &lt;- function(n=1) {\n  # n gives the number of samples, with the default of 1\n  rexp(n, rate = lambda)\n}\n\n\n\n\n\n\n\nTip\n\n\n\n&lt;- and = are chosen to follow convention. &lt;- assigns a “value” to a variable while = is used in function signatures.\n\n\n\n\nSampling Random Variable\nSample it once:\n\nX()\n\n[1] 142.1073\n\n\nSample it several times:\n\nX(5)\n\n[1]  163.0190 5211.4445 6703.1780 5854.9573  629.4449\n\n\nAveraging a few samples\n\nmean(X(15))\n\n[1] 3050.265\n\n\nAveraging a lot of samples\n\nmean(X(15000))\n\n[1] 1990.038\n\n\n\n\nN-Sample Visualization\n\n\nCode\n# set the samples and increment\nn_values = seq(10, 5000, by = 10)\n\n# create a tibble with N, mean, and sd for sampling X() n times\nX_sim &lt;- tibble(\n  n = n_values,\n  Mean = map_dbl(n_values, ~ mean(X(.x))),\n  SD = map_dbl(n_values, ~ sd(X(.x)))\n)\n\n#plot results\nX_sim %&gt;%\n  ggplot(aes(x = n, y = Mean)) +\n  geom_line(color = \"blue\") +\n  geom_ribbon(aes(ymin = Mean - SD, ymax = Mean + SD), fill = \"blue\", alpha = 0.2) +\n  scale_x_log10() +\n  labs(\n    x = \"Sample Size (n)\",\n    y = \"Mean ± SD\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nSimulation Code\n\n# Initialize total breakdown count\nbreakdowns &lt;- 0\n\n# Iterate over each turbine\nfor (k in 1:K) {\n  # simulate for N years\n  for (n in 1:N) {\n    # Reset initial time to 0\n    t &lt;- 0\n    \n    # while t is less than one year\n    while (t &lt;= yr) {\n      # Sample from the exponential distribution (time to next breakdown)\n      t &lt;- t + X()\n      \n      # Increment the breakdown count if within the simulation period\n      if (t &lt;= yr) {\n        breakdowns &lt;- breakdowns + 1\n      }\n    }\n  }\n}\n\n# Calculate the average number of breakdowns per year across all turbines\nbreakdowns &lt;- breakdowns / N\n\nWe should expect 1324.2 breakdowns in a year for the 300-turbine wind farm.\n\n\nCode Flow Chart:\n\n\n\n\n\nflowchart LR\n  A[\"X ~ Exp(λ)\n  breakdowns = 0\n  t = 0\"]\n  B{\"t &lt;= 1 year\"}\n  C[\"t += X()\"]\n  D{\"t &lt;= 1 year\"}\n  E[\"breakdowns++\"]\n  Terminate([Terminate])\n  \n  A --&gt; B\n  B --true--&gt; C\n  C --&gt; D\n  D --true--&gt; E\n  D --false--&gt; B\n  E --&gt; B\n  B --false-----&gt; Terminate\n\n\n\n\n\n\n\n\nSmarter Simulation\n\nExponential gives time between events\nPoisson gives number of events in a given time\n\n\n# Poisson parameter is # events per time period\nlambda_p &lt;- yr * lambda\n\n# we want to sample K*N times, This gives K*N breakdowns (vector)\npoisson_breakdowns &lt;- rpois(N*K, lambda_p)\n\n# sum the vector and divide by N\npoisson_breakdowns &lt;- sum(poisson_breakdowns) / N\n\nWe should expect 1309.8 breakdowns in a year for the 300-turbine wind farm.\n\n\n\n\n\n\nTip\n\n\n\nSearch documentation by going to the lower right pane and clicking the “Help” tab. Then type your term (i.e. rpois) into the search bar.",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#wind-turbine-repair",
    "href": "recitations/R1_nb.html#wind-turbine-repair",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.2 Wind Turbine Repair",
    "text": "2.2 Wind Turbine Repair\nRepairs are assumed to take 96 hours (the average). How much turbine-down time should be expected per year? How many breakdowns should be anticipated per year?\n\nAnalytical Solution\n\nWith a fixed repair time, we can tack 96 hours on to the breakdown rate, 1 break down every2000 hours + 96 hours to repair = 1 breakdown every 2096.\n\n\\[\nN = 300\\ turbines \\frac{365\\ days}{year} \\frac{24\\ hrs}{day} \\frac{1\\ breakdown/turbine}{2,096\\ hrs} = 1,253.8\\ breakdowns/year\n\\]\n\nAccounting for repair time, our number of breakdowns…decreased? Is this sensible?\n\n\\[\nN = 300\\ turbines \\frac{365\\ days}{year} \\frac{24\\ hrs}{day} \\frac{96\\ hrs\\ downtime}{2,096\\ hrs\\ operation} = 120,366.4\\ hrs\\ downtime\n\\]\n\nAre we confident that this math checks out? Let’s simulate it…\n\n\n\nSimulation Modification\n\n# repair time, Y\nY &lt;- params$repair_avg\n\n# Initialize breakdowns and uptime\nbreakdowns &lt;- 0\nuptime &lt;- 0\n\n# Iterate over each turbine\nfor (k in 1:K) {\n  # simulate for N years\n  for (n in 1:N) {\n    # Reset simulation time to 0\n    t &lt;- 0\n    \n    # while t is less than one year\n    while (t &lt;= yr) {\n      \n      # sample breakdown time\n      time_to_breakdown &lt;- X()\n\n      # check if the breakdown time will exceed a year\n      if (t + time_to_breakdown &lt;= yr) {\n        # if not, then we get another breakdown\n        breakdowns &lt;- breakdowns + 1\n        # the simulation time increases by the time to breakdown\n        t &lt;- t + time_to_breakdown\n        # and the uptime increases by the time to breakdown\n        uptime &lt;- uptime + time_to_breakdown\n        \n        # for now, Y is a constant\n        time_to_repair &lt;- Y\n\n        t &lt;- t + time_to_repair\n        \n      } else {\n        # if the breakdown time exceeds one year, then uptime\n        # extends to the end of the year and we don't get a new breakdown\n        uptime &lt;- uptime + (yr - t)\n        t &lt;- t + time_to_breakdown\n      }\n    }\n  }\n}\n\n# Calculate the average number of breakdowns per year across all turbines\nuptime &lt;- uptime / N\nbreakdowns &lt;- breakdowns / N\ndowntime &lt;- 300*yr - uptime\n\n\n\nResults Comparison\n\n\n\n\n\n\n\n\nMetric\nAnalytical\nSimulation\n\n\n\n\n\\(breakdowns/yr\\)\n1253.8\n1249.28\n\n\n\\(total\\ turbine\\ downtime/yr\\)\n120366.4\n119323.5\n\n\n\n\nShortfalls?\n\n\nAssumes every turbine is working at the start of the simulation\nWhat can we say about the probability of downtime exceeding some value?\nIf we want to increase up time, should we focus on expediting repairs or performing preventive maintenance to increase time between failures?\nDo all repairs take the same amount of time?",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#lognormally-distributed-repair-time",
    "href": "recitations/R1_nb.html#lognormally-distributed-repair-time",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.3 LogNormally Distributed Repair Time",
    "text": "2.3 LogNormally Distributed Repair Time\n\nMost repairs take about the same amount of time, but some take a long time (think specialty overseas parts etc).\n\n\\[\nY \\sim LogNormal(\\mu, \\sigma^2)\n\\] \\[\nf_Y(t | \\mu, \\sigma) = \\frac{1}{\\sqrt{2\\pi \\sigma t}} \\exp \\left( \\frac{-(log(t)-\\mu)^2}{2\\sigma^2} \\right)\n\\]\n\nLogNormal Distribution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese are the same distribution with the left x-axis on a log scale. The lower end of ranges look basically like a Normal distribution for both plots, but the right plot shows that the higher values of \\(t\\) are more likely than if it were just a Normal distribution. The pdf looks like it is being stretched.\n\n\nCreating LogNormal Distribution\n\nmu &lt;- params$repair_avg\nsigma &lt;- params$repair_std\nmu_log &lt;- log( mu^2 / ( mu^2 + sigma^2)^(1/2) )\nsigma_log &lt;- (log(1 + (sigma^2/mu^2)))^(1/2)\n\nY &lt;- function(n=1){\n  rlnorm(n, mu_log, sigma_log)\n}\n\n\n\nVerifying LogNormal Distribution\n\nrepair_times &lt;- Y(500)\n\nmu_calc &lt;- mean(repair_times)\nsigma_calc &lt;- sd(repair_times)\n\n\nSample mean: 97.4148942\nSample standard deviation: 26.4721265\n\n\n\n\n\n\n\nTip\n\n\n\nYou often can’t validate your entire simulation. However, you can and should verify the components as much as possible\n\n\n\n\nAnalytical Solution\n\nNeed to determine how many times \\(X + Y\\) divide into one year\nAdding two distributions is not straightforward. How do you add a pair of 6-sided die?\nThis is really a convolution, denoted as \\(X \\ast Y\\). It can be found as:\n\n\\[(f_X * f_Y)(t) = \\int_{-\\infty}^{\\infty} f_X(\\tau) f_Y(t - \\tau) \\, d\\tau\\]\n\nSometimes, this can be achieved easier through Laplace Transforms\nUnfortunately, a closed-form analytical solution is not always possible\n\n\n\nSimulation Adjustment\n\n# Initialize breakdowns and uptime\nbreakdowns &lt;- 0\nuptime &lt;- 0\n\n# Iterate over each turbine\nfor (k in 1:K) {\n  # simulate for N years\n  for (n in 1:N) {\n    # Reset simulation time to 0\n    t &lt;- 0\n    \n    # while t is less than one year\n    while (t &lt;= yr) {\n      \n      # sample breakdown time\n      time_to_breakdown &lt;- X()\n\n      # check if the breakdown time will exceed a year\n      if (t + time_to_breakdown &lt;= yr) {\n        # if not, then we get another breakdown\n        breakdowns &lt;- breakdowns + 1\n        # the simulation time increases by the time to breakdown\n        t &lt;- t + time_to_breakdown\n        # and the uptime increases by the time to breakdown\n        uptime &lt;- uptime + time_to_breakdown\n        \n        # now we will sample Y\n        time_to_repair &lt;- Y()\n\n        t &lt;- t + time_to_repair\n        \n      } else {\n        # if the breakdown time exceeds one year, then uptime\n        # extends to the end of the year and we don't get a new breakdown\n        uptime &lt;- uptime + (yr - t)\n        t &lt;- t + time_to_breakdown\n      }\n    }\n  }\n}\n\n# Calculate the average number of breakdowns per year across all turbines\nuptime &lt;- uptime / N\nbreakdowns &lt;- breakdowns / N\ndowntime &lt;- 300*yr - uptime\n\n\n\nResults Comparison, LogNormal Dist.\n\n\n\n\n\n\n\n\nMetric\nAnalytical\nSimulation\n\n\n\n\n\\(breakdowns/yr\\)\n1253.8\n1245.52\n\n\n\\(total\\ turbine\\ downtime/yr\\)\n120366.4\n118613.5",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R1_nb.html#collecting-more-simulation-data",
    "href": "recitations/R1_nb.html#collecting-more-simulation-data",
    "title": "#1 Simulations Overview (Wind Turbine Repair)",
    "section": "2.4 Collecting more Simulation Data",
    "text": "2.4 Collecting more Simulation Data\nWe want to ask questions about the distribution of failures and repairs. We need to collect more data from the simulation and store it in an easy format for manipuation.\n\nTidy Data & Tidyverse\n\n# Create an empty table which we will populate during simulation\nresults &lt;- tibble(\n  turbine_id = integer(),\n  year = integer(),\n  breakdowns = integer(),\n  uptime = numeric()\n)\n\n\n\n\n\n\n\nTip\n\n\n\ntidyverse is the one-stop-shop for (nearly) everything needed for working with data and creating great visualizations. It includes several different packages which all adhere to the “tidy” way of doing things. We’ll see more of this in the future.\n\n\n\n\nFinal Simulation\n\n# Iterate over each turbine\nfor (k in 1:K) {\n  # simulate for N years\n  for (n in 1:N) {\n    # move these to inner loop to record results of each iteration\n    breakdowns &lt;- 0\n    uptime &lt;- 0\n    t &lt;- 0\n    \n    # while t is less than one year\n    while (t &lt;= yr) {\n      \n      # sample breakdown time\n      time_to_breakdown &lt;- X()\n\n      # check if the breakdown time will exceed a year\n      if (t + time_to_breakdown &lt;= yr) {\n        # if not, then we get another breakdown\n        breakdowns &lt;- breakdowns + 1\n        # the simulation time increases by the time to breakdown\n        t &lt;- t + time_to_breakdown\n        # and the uptime increases by the time to breakdown\n        uptime &lt;- uptime + time_to_breakdown\n        \n        # now sampling Y\n        time_to_repair &lt;- Y()\n\n        t &lt;- t + time_to_repair\n        \n      } else {\n        # if the breakdown time exceeds one year, then uptime\n        # extends to the end of the year and we don't get a new breakdown\n        uptime &lt;- uptime + (yr - t)\n        t &lt;- t + time_to_breakdown\n      }\n    }\n    \n    # write the data to the rows of our tibble\n    results &lt;- results |&gt;\n      add_row(\n        turbine_id = k,\n        year = n,\n        breakdowns = breakdowns,\n        uptime = uptime\n      )\n  }\n}\n\n# calculating a column for downtime \nresults &lt;- results |&gt;\n  mutate(downtime = yr - uptime)\n\n\n\nSimulation Visualizations\n\nBreakdownsDowntimeDowntime vs. Breakdowns\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResults Cumulative Distributions\n\nTotal BreakdownsAnnual Downtime",
    "crumbs": [
      "Tutorials",
      "#1 Simulations Overview (Wind Turbine Repair)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html",
    "href": "recitations/R3_nb.html",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "",
    "text": "Notice this was excluded from the Table of Contents and is not numbered.",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#front-matter",
    "href": "recitations/R3_nb.html#front-matter",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "1.1 Front Matter",
    "text": "1.1 Front Matter\n---\ntitle: \"R3 Waiting in Line\"\nsubtitle: \"14:540:384: Simulation Models in IE (Spring 2025)\"\nauthor:\n  - name: Daniel Moore\n    email: daniel.l.moore@rutgers.edu\n    affiliation: \n      - name: Rutgers University\n        city: Piscataway\n        state: NJ\n        url: https://sites.rutgers.edu/ropes-lab/\n   \ndate: 2025-02-04\nimage: \"../assets/queue_plot.jpeg\"\ndate-format: iso\n\nformat:\n  pdf:\n    number-sections: true\n    toc: true\n    toc-depth: 3\n    number-depth: 3\n    output-file: R3_pdf\n    df-print: kable\n\nabstract: This document shows some basics about how to leverage Quarto to make your life easier and how to create some neat animations.\n---",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#cell-options",
    "href": "recitations/R3_nb.html#cell-options",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "1.2 Cell Options",
    "text": "1.2 Cell Options\n#| eval: true       # whether to execute code when you render the doc\n#| echo: false      # decide if code is shown in the document or hidden\n#| output: false    # should the output of the chunk be displayed\n#| warning: false   # do you want warnings to be shown in the document\n#| error: false     # do you want error messages to apepar in the doc?\n#| include: false   # Catch all for preventing any output",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#formulas-and-references",
    "href": "recitations/R3_nb.html#formulas-and-references",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "1.3 Formulas and references",
    "text": "1.3 Formulas and references\n\ncreate a cross referencable item with #fig-your-reference-name. Use the appropriate reserved prefix such as: fig, tbl, lst, tip, nte, wrn, imp, cau, thm, lem, cor, prp, cnj, def, exm, exr, sol, rem, eq, sec.\nlink words in your reference with -. Do not using blank space, , or underscores _.\nReference your item where you want with @fig-your-reference-name.\nSee the Quarto References Guide for how to get different formats of your reference such as: “Figure 1”, “Fig 1”, “1” etc.\n\nThe probability density function (pdf) of the exponential distribution is\ngiven below in @eq-exponential-distribution.\n\n$$\np(t) = \\lambda e^{-\\lambda t}\n$$ {#eq-exponential-distribution}\nThe probability density function (pdf) of the exponential distribution is given below in Equation 1.\n\\[\np(t) = \\lambda e^{-\\lambda t}\n\\tag{1}\\]",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#problem-definition",
    "href": "recitations/R3_nb.html#problem-definition",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "2.1 Problem Definition",
    "text": "2.1 Problem Definition\nFrom 4:00 PM to 7:00 PM, customers arrive at Whole Foods to make Amazon returns following a Poisson process with a rate of \\(\\lambda = \\frac{1\\ customer}{3\\ min}\\). A single clerk services the returns at a rate of \\(\\mu = \\frac{1\\ customer}{2\\ min}\\).\nWhat can we say about the:\n\nExpected wait time?\nExpected total time in the system?\nWhat is the probability of seeing more than 5 people in line?\nServer Utilization Rate?",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#coding-the-simulation",
    "href": "recitations/R3_nb.html#coding-the-simulation",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "2.2 Coding the simulation",
    "text": "2.2 Coding the simulation\n\nFor previous examples, we stepped through time and sampled the random variables, keeping track of the results\nFor this example, we will sample all the random variables and perform some logic to determine the results\nThis method is more computationally efficient because loops can slow down R and Python\nOn the one hand, sampling the random variables this way is more convincing because the memoryless property of the exponential distribution can be a hard concept to grasp and we are kind of pushing that issue out of the way\nOn the other hand, this method requires a little more reasoning about what is happening in the system after the random variables are sampled\n\n\n2.2.1 Packages\n\nlibrary(tidyverse)\nlibrary(knitr)\n\n# setting a random seed for reproducibility\nset.seed(1766)\n\n\n\n2.2.2 Parameters\n\nlambda &lt;- 1/3\narrive &lt;- function(n=1) {\n  rexp(n, rate = lambda )\n}\n\nmu &lt;- 1/2\nservice &lt;- function(n=1) {\n  rexp(n, rate = mu)\n}\n\nt_f &lt;- 3 * 60\n\n# double the number of samples to make sure we will have enough to exceed t_f\nsamples &lt;- round(2 * t_f * lambda)\n\n\n\n2.2.3 Generating Arrival and Service Times\n\ndata &lt;- tibble(\n  interarrival_time = arrive(samples),\n  service_time = service(samples)\n)\n\ndata &lt;- data |&gt; mutate(\n  arrival_time = cumsum(interarrival_time)\n)\n\ndata &lt;- data |&gt; filter(arrival_time &lt;= t_f)\n\ndata &lt;- data |&gt; mutate(\n  service_start_time = 0,\n  departure_time = 0)\n\n\n\n2.2.4 Running the Simulation\n\nt_0 &lt;- 0\nnext_available_time &lt;- t_0\n\nfor (i in 1:nrow(data)) {\n  # Service starts when the server is available\n  data$service_start_time[i] &lt;- max(data$arrival_time[i], next_available_time)\n  \n  # Compute departure time\n  data$departure_time[i] &lt;- data$service_start_time[i] + data$service_time[i]\n  \n  # Update when the server wœill next be available\n  next_available_time &lt;- data$departure_time[i]\n}\n\n\n\n2.2.5 Calculating Performance Measures\n\ndata &lt;- data |&gt; mutate(\n  wait_time = service_start_time - arrival_time,\n  total_time = departure_time - arrival_time\n)\n\ndata &lt;- data |&gt; mutate(\n  number_serviced_by_arrival = 0,\n  L = 0, # number in system, waiting + being serviced. Starting at 0\n  L_q = 0 # number in queue\n)\n\nfor (i in 2:nrow(data)) {\n  this_arrival &lt;- data$arrival_time[i]\n  data$number_serviced_by_arrival[i] &lt;- sum(data$departure_time[1:i-1] &lt; this_arrival)\n}\n\nfor (i in 1:nrow(data)) {\n  data$L[i] &lt;- i - data$number_serviced_by_arrival[i]\n  data$L_q[i] &lt;- max(0, data$L[i] - 1)\n}\n\nhead(data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninterarrival_time\nservice_time\narrival_time\nservice_start_time\ndeparture_time\nwait_time\ntotal_time\nnumber_serviced_by_arrival\nL\nL_q\n\n\n\n\n0.6624587\n5.2966049\n0.6624587\n0.6624587\n5.959064\n0.0000000\n5.2966049\n0\n1\n0\n\n\n9.3129468\n2.5289920\n9.9754055\n9.9754055\n12.504397\n0.0000000\n2.5289920\n1\n1\n0\n\n\n0.3265047\n2.9688180\n10.3019102\n12.5043975\n15.473216\n2.2024873\n5.1713053\n1\n2\n1\n\n\n0.2567624\n2.1481199\n10.5586726\n15.4732155\n17.621335\n4.9145429\n7.0626628\n1\n3\n2\n\n\n0.5007908\n1.0292805\n11.0594634\n17.6213354\n18.650616\n6.5618719\n7.5911524\n1\n4\n3\n\n\n7.1882326\n0.4291179\n18.2476961\n18.6506159\n19.079734\n0.4029198\n0.8320377\n4\n2\n1\n\n\n\n\n\n\nNote that this table will look bad in the PDF. We’ll explicitly use kable() to make it look better. Look at Table 1 to see compare the outputs.\n\nkable(head(data), digits=2, col.names =\n  c(\"Interarrival Time\", \"Arrival Time\", \"Service Time\", \"Service Start Time\", \"Departure Time\", \"Wait Time\", \"Total Time\", \"Serviced by Arrival\", \"L\", \"L_q\"))\n\n\n\nTable 1: Data Formatted with Kable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterarrival Time\nArrival Time\nService Time\nService Start Time\nDeparture Time\nWait Time\nTotal Time\nServiced by Arrival\nL\nL_q\n\n\n\n\n0.66\n5.30\n0.66\n0.66\n5.96\n0.00\n5.30\n0\n1\n0\n\n\n9.31\n2.53\n9.98\n9.98\n12.50\n0.00\n2.53\n1\n1\n0\n\n\n0.33\n2.97\n10.30\n12.50\n15.47\n2.20\n5.17\n1\n2\n1\n\n\n0.26\n2.15\n10.56\n15.47\n17.62\n4.91\n7.06\n1\n3\n2\n\n\n0.50\n1.03\n11.06\n17.62\n18.65\n6.56\n7.59\n1\n4\n3\n\n\n7.19\n0.43\n18.25\n18.65\n19.08\n0.40\n0.83\n4\n2\n1\n\n\n\n\n\n\n\n\nWe could also break this table up into a few different groups of columns so that it fits on the page nicer. This is good enough for us for now.",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#visualizing-the-results",
    "href": "recitations/R3_nb.html#visualizing-the-results",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "2.3 Visualizing the Results",
    "text": "2.3 Visualizing the Results\n\n2.3.1 Queue Length Histogram\nFigure 1 shows the distribution of queue lengths.\n\ndata |&gt; ggplot(aes(x=L)) +\n  geom_histogram(fill=\"cornflowerblue\", color=\"black\") +\n  labs(\n    title = \"Queue Length Histogram\",\n    x = \"Number of Customers in Queue\",\n    y = \"Count\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nFigure 1: Histogram of Queue Lengths\n\n\n\n\n\n\n\n2.3.2 Waiting Time Histogram\nFigure 2 shows the distribution of waiting times.\n\ndata |&gt; ggplot(aes(x=wait_time)) +\n  geom_histogram(fill=\"cornflowerblue\", color=\"black\") +\n  labs(\n    title = \"Waiting Time Histogram\",\n    x = \"Waiting Time (min)\",\n    y = \"Count\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nFigure 2: Histogram of Waiting Times\n\n\n\n\n\n\n\n2.3.3 Waiting Time Density\nIf we want to view any of these as a probability density we could use stat_density or geom_density. There are a whole host of different plots that you should browse to see what could be good at telling the story you are trying to convey.\n\ndata |&gt; ggplot(aes(x = wait_time)) +\n  geom_density() +\n  labs(\n    x = \"Time in the System (min)\",\n    y = \"Probability Density\"\n  )\n\n\n\n\n\n\n\nFigure 3: System Waiting Time Density Plot\n\n\n\n\n\n\n\n2.3.4 Queue Length Over Time\nFigure 5 shows the queue length over time. However, this isn’t really the full story. What we want to see is how the system changes at each arrival and departure. To do this, we will need to create a new data frame that has an entry for each arrival and departure. Additionally, we’ll want the numbers indicated to be horizontal lines with discontinuities showing when the number changes. Also, this is not exactly the bounds of our simulation because we cutoff our arrivals at \\(t_f\\), but we have departures after that time. So we should only be plotting up to \\(t_f\\).\n\ndata |&gt; ggplot(aes(x=arrival_time, y=L_q)) +\n  geom_line(color=\"cornflowerblue\") +\n  labs(\n    title = \"Queue Length Over Time\",\n    x = \"Time (min)\",\n    y = \"Number of Customers in Queue\"\n  )\n\n\n\n\n\n\n\nFigure 4: Queue Length Over Time\n\n\n\n\n\nThe way these lines are connected give an indication that the queue length is in between two integers at most times. Line plots can be misleading in this way. We need a step plot. Also, we are essentially only sampling the system at a time that somebody arrives. This is why we are seeing big jumps. We should only be seeing the line move up or down one at a time.\n\nEvent Log\nBasically, we need to unpack the simulation data so that it is event-centric rather than customer-centric.\n\n# all events are either arrivals or departures\n# create a dataframe which tracks all events\n# combines arrival and departure times into single vector, event time\n# for arrivals, event is +1\n# for departures, event is -1\n\nevents &lt;- data |&gt;\n  # bringing the data I want to work with\n  select(arrival_time, departure_time) |&gt; \n  \n  # turning the data from wide to long\n  pivot_longer(\n    cols = everything(),\n    names_to = \"event_type\",\n    values_to = \"event_time\") |&gt; \n  \n  # assigning -1 if departure and 1 if arrival\n  mutate(\n    event = ifelse(event_type == \"arrival_time\", 1, -1)) |&gt;\n  \n  # adding an initial condition of time=0 and 0 customers\n  bind_rows(tibble(event_time = 0, event = 0)) |&gt;\n  \n  # removing the event type column\n  select(-event_type) |&gt;\n  \n  # sorting the data by event time\n  arrange(event_time)\n\n# cumulative sum of events\nevents &lt;- events |&gt; mutate(\n  L = cumsum(event),\n  # pmax is vectorized function that looks at each element rather than the entire thing\n  L_q = pmax(0, L - 1)  \n)\n\nhead(events)\n\n\n\n\n\nevent_time\nevent\nL\nL_q\n\n\n\n\n0.0000000\n0\n0\n0\n\n\n0.6624587\n1\n1\n0\n\n\n5.9590636\n-1\n0\n0\n\n\n9.9754055\n1\n1\n0\n\n\n10.3019102\n1\n2\n1\n\n\n10.5586726\n1\n3\n2\n\n\n\n\n\n\nWe could plot this by adding each column to the plot one at a time, but this can get messy. Instead we’ll do a pivot_longer so that the data is in a better format for plotting multiple series together.\nHere I’m pivoting from a wide format (have both an L and an L_q column) to a long format which just has the x-value of time and the y-value of L or L_q. This makes plotting much easier.\n\nevents_long &lt;- events |&gt; \n  pivot_longer(\n    cols = c(L, L_q), \n    names_to = \"metric\", \n    values_to = \"value\"\n  )\n\nhead(events_long)\n\n\n\n\n\nevent_time\nevent\nmetric\nvalue\n\n\n\n\n0.0000000\n0\nL\n0\n\n\n0.0000000\n0\nL_q\n0\n\n\n0.6624587\n1\nL\n1\n\n\n0.6624587\n1\nL_q\n0\n\n\n5.9590636\n-1\nL\n0\n\n\n5.9590636\n-1\nL_q\n0\n\n\n\n\n\n\nAt last, Figure 5 shows a complete plot of the number of customers in line and the number in the system at each moment.\n\nevents_long |&gt; ggplot(aes(x = event_time, y = value, color=metric)) +\n  xlim(0, t_f) +\n  geom_step(direction = \"hv\") +\n  labs(\n    title = \"Customer Count Over Time\",\n    x = \"Time (min)\",\n    y = \"Customers\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 5: Customer Count Over Time",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#concepts",
    "href": "recitations/R3_nb.html#concepts",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "3.1 Concepts",
    "text": "3.1 Concepts\n\nData in long format: Structure data with one row per observation and a time variable for animations (use pivot_longer() for multiple metrics).\nTime variable for transitions: Use a continuous variable (e.g., event_time) to animate data over time with transition_reveal() or transition_states().\nCompatible geom layers: Use geom_step(), geom_line(), or geom_point() to animate time-series data, ensuring smooth transitions.",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#code",
    "href": "recitations/R3_nb.html#code",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "3.2 Code",
    "text": "3.2 Code\n\nlibrary(gganimate)\nlibrary(gifski)\n\nNote that I have this cell set up to not execute with #| eval: false. I used this exact code to create and save the plot as shown, but I don’t want to re-render and save over it every time.\n\np &lt;- events_long |&gt; \n  ggplot(aes(x = event_time, y = value, color = metric)) +\n  geom_step(size = 1.2) + \n  labs(x = \"Time\", y = \"Customers\", color = \"Metric\") +\n  theme_minimal() +\n  transition_reveal(event_time)\n\n# Animate and save as GIF\nanim &lt;- animate(p, renderer = gifski_renderer(),\n  width = 800, height = 600, duration = 5)\nanim_save(\"returns_animation.gif\", animation = anim)\n\nanim\n\n\n\n\nQueueing Animation",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#formulae",
    "href": "recitations/R3_nb.html#formulae",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "4.1 Formulae",
    "text": "4.1 Formulae\n\\[\nServer\\ Utilization, \\rho = \\frac{\\lambda}{\\mu} = \\frac{1/3}{1/2}\n\\tag{2}\\]\n\\[\nExpected\\ Number\\ in\\ the\\ System,\\ L = \\frac{\\lambda}{\\mu - \\lambda}\n\\tag{3}\\]\n\\[\nExpected\\ Number\\ in\\ the\\ Queue,\\ L_q = \\frac{\\lambda^2}{\\mu(\\mu - \\lambda)}\n\\tag{4}\\]\n\\[\nExpected\\ time\\ in\\ the\\ System,\\ W = \\frac{1}{\\mu - \\lambda}\n\\tag{5}\\]\n\\[\nExpected\\ time\\ in\\ the\\ Queue,\\ W_q = \\frac{\\lambda}{\\mu(\\mu - \\lambda)}\n\\tag{6}\\]\n\\[\nProbability\\ of\\ empty\\ system, P_0 = 1 - \\rho\n\\tag{7}\\]\n\\[\nProbability\\ of\\ n\\ customers\\ in\\ the\\ System,\\ P(n) = (1 - \\rho)\\rho^n\n\\tag{8}\\]",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#calculations",
    "href": "recitations/R3_nb.html#calculations",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "4.2 Calculations",
    "text": "4.2 Calculations\n\n# \nP_n &lt;- function(n, rho) {\n  (1 - rho) * rho^n\n}\n\nperformance_measures &lt;- data.frame(\n  Performance_Measure = c(\"L\", \"L_q\", \"W\", \"W_q\", \"rho\"),\n  Analytical = c(\n    lambda / (mu - lambda),\n    (lambda^2) / (mu * (mu - lambda)),\n    1 / (mu - lambda),\n    lambda / (mu * (mu - lambda)),\n    lambda / mu\n  )\n)",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#think-critically",
    "href": "recitations/R3_nb.html#think-critically",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "5.1 Think Critically!",
    "text": "5.1 Think Critically!\n\nThink for a minute about the way our two data frames are structured. Is all of the information there? What do we need to consider to get it.",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#performance-measure-notes",
    "href": "recitations/R3_nb.html#performance-measure-notes",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "5.2 Performance Measure Notes",
    "text": "5.2 Performance Measure Notes\n\nThe performance measures, \\(L\\) and \\(L_q\\) are supposed to represent the expected number of custoemrs in the system and in the queue\nThe first data is customer centric. All we see is how many people are in line when the customer shows up. \\(W\\) and \\(W_q\\) are obtainable from this.\nThe second is event centric. We see the time that an event happens and the customers at that time.\nThis means essentially we are just sampling at these points. It might be a good representation of the number in the system, but it might not be. Notably, we could definitely have systematic error because this “sampling” isn’t even random, it is always as events",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#what-to-do",
    "href": "recitations/R3_nb.html#what-to-do",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "5.3 What to do?",
    "text": "5.3 What to do?\n\nWe need to take the time-weighted average of the number of people in the system and in line\nThis data is available in the events data frame, but it will take a little more manipulation:\n\n\nevents &lt;- events |&gt; mutate(\n  time_in_state = coalesce(lead(event_time), t_f) - event_time\n)\n\nCoalesce gives us a default value to use. Since we are differencing each row with the one after it, when we get to the last row there’s nothing there. So we need to say the last row’s lead even time is the end of the simulation, t_f.\n\nperformance_measures &lt;- performance_measures |&gt; mutate(\n  Simulation = c(\n    sum(events$L * events$time_in_state) / t_f,\n    sum(events$L_q * events$time_in_state) / t_f,\n    mean(data$total_time),\n    mean(data$wait_time),\n    sum(events$time_in_state[events$L &gt; 0]) / t_f\n  )\n)\n\nNow we can compare the analytical results in Table 2 and the correctly calculated simulation performance measures.\n\nkable(performance_measures, digits = 3)\n\n\n\nTable 2: Simulation and Analytical Comparison\n\n\n\n\n\n\nPerformance_Measure\nAnalytical\nSimulation\n\n\n\n\nL\n2.000\n1.190\n\n\nL_q\n1.333\n0.643\n\n\nW\n6.000\n3.692\n\n\nW_q\n4.000\n1.995\n\n\nrho\n0.667\n0.547\n\n\n\n\n\n\n\n\n\n\n\nTable 3: Calculating P(n)\n\n\nn_in_system_ps &lt;- tibble(n = 0:10) |&gt;\n  mutate(\n    Analytical = P_n(0:10, lambda/mu),\n    Simulation = sapply(0:10, function(k) sum(events$time_in_state[events$L == k]) / t_f)\n  )\n\nkable(n_in_system_ps, digits=3)\n\n\n\n\n# first we need to get the data into long format\n\nn_in_system_ps |&gt;\n  pivot_longer(\n    cols = c(Analytical, Simulation),\n    names_to = \"method\",\n    values_to = \"p\"\n  ) |&gt;\n  ggplot(aes(x = n, y = p, fill = method, group = method)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  labs(x = \"n\", y = \"Probability\", title = \"Probabilities by Method\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 6: Corrected P(n) Histogram\n\n\n\n\n\nI’ll leave it to you to compare these results with an incorrect method which would be simply averaging from the sampled data or the events log without accounting for time.",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#potential-complications",
    "href": "recitations/R3_nb.html#potential-complications",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "6.1 Potential Complications?",
    "text": "6.1 Potential Complications?\n\nWhat if there is a limited amount of space and if the line is too long, customers just leave?\nService times follow different distributions?\nMore than one line? More than one server?\nPriority line with different logic? Maybe a commerical customer with 12 packages gets serviced as soon as a server is available?",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R3_nb.html#summary",
    "href": "recitations/R3_nb.html#summary",
    "title": "#3 Queuing and Animations (Amazon Returns)",
    "section": "6.2 Summary",
    "text": "6.2 Summary\n\nWe simulated an \\(M/M/1\\) queuing system by sampling arrival and service times\nWe obtained system state measurements by executing logic on the samples\nManipulated the data into an event time series\nCreated and animated geom_step plots using ggplot, gganimate, and gifski\nCompared analytical system metrics to those we obtained from the simulation.\nNoted how we must account for time to get correct performance measures",
    "crumbs": [
      "Tutorials",
      "#3 Queuing and Animations (Amazon Returns)"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html",
    "href": "recitations/R8_nb.html",
    "title": "#8 Gas Station Template",
    "section": "",
    "text": "Schedule Resources\nDynamically interact with simulation (retrieve information and change behavior)\nLock resources (TBC)\nDefine alternative trajectories",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#scheduling-resources",
    "href": "recitations/R8_nb.html#scheduling-resources",
    "title": "#8 Gas Station Template",
    "section": "3.1 Scheduling Resources",
    "text": "3.1 Scheduling Resources\nEach day, there are 5 individuals scheduled - two in the morning, two in the afternoon, and one in between. Lunch is staggered as shown below.\n\n\n\n\n\ngantt\n  todayMarker off\n    title Daily Shift Schedule\n    dateFormat HH:mm\n    axisFormat %H:%M\n\n    section Attendants\n    1       :a1, 07:00, 4h\n    1       :a1, 12:00, 4h\n    2       :a2, 07:00, 4h\n    2       :a2, 12:00, 4h\n    3       :a3, 10:00, 2h\n    3       :a3, 13:00, 6h\n    4       :a4, 10:00, 2h\n    4       :a4, 13:00, 6h\n    5       :a5, 09:00, 4h\n\n\n\n\n\n\nWe use schedule from simmer to build a schedule object which will be used when we add these resources to the simmer environment.\n\nwe create a vector of each time that the number of workers is changing\ncreate another vector which is the number that are available starting at that time. Note that the first element in timetable is 7 and the corresponding value in values is 2 because 2 workers start. Similarly, at 19, the workers go back to 0\nthis schedule is set to repeat every 24 hours\nI multiply the time values by 60 so that everything in the model stays in minutes (because that’s what I want to work in)\n\n\ncrew_schedule &lt;- schedule(\n  timetable = 60 * c(7, 9, 10, 11, 12, 13, 16, 19),\n  values = c(2, 3, 5, 3, 3, 4, 2, 0),\n  period = 24 * 60)\n\n\nstation_schedule &lt;- schedule(\n  timetable = 60 * c(7, 19),\n  # I'm giving the facility infinite servers so that I can track\n  # how many cars are in the system total. This doesn't mean how many pumps\n  # we have.\n  values = c(Inf, 0),\n  period = 24 * 60)",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#customer-distributions",
    "href": "recitations/R8_nb.html#customer-distributions",
    "title": "#8 Gas Station Template",
    "section": "3.2 Customer Distributions",
    "text": "3.2 Customer Distributions\nWe need to define a distribution for customer interarrival time and total gas demand. For simplicity we are given distributions to use directly so we don’t need to first fit distributions to data and select the best one.\n\ncars_per_min &lt;- 250 / (12 * 60)\n\ncar_interarrival &lt;- function(n=1) {\n  rexp(n, rate = cars_per_min)\n}\n\ngal_gas &lt;- function(n=1) {\n  100 * rweibull(n, 5.3, 11)\n}\n\nNote that here I am multiplying the gallons demanded by 100. This is so that I can add integer valued resources to the model. There are other ways this could be handled but this is an elegant solution propsoed by Mike DeBellis.",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#service-time-distributions",
    "href": "recitations/R8_nb.html#service-time-distributions",
    "title": "#8 Gas Station Template",
    "section": "3.3 Service Time Distributions",
    "text": "3.3 Service Time Distributions\n\ninitiate_service &lt;- function(n=1) {\n  rtpexp(n, 25/60, .75)\n}\n\nfinalize_service &lt;- function(n=1) {\n  rtpexp(n, 30/60, .9)\n}\n\ngal_per_min &lt;- 5",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#other-data",
    "href": "recitations/R8_nb.html#other-data",
    "title": "#8 Gas Station Template",
    "section": "3.4 Other Data",
    "text": "3.4 Other Data\n\n# number of cars at which arrivals will consider leaving\ntoo_many_cars &lt;- 10\n\n# probability at which they will leave\np_leave_too_many &lt;- 0.75\n\n# multiplying by 100 gets us integer values of \"gas\" resources with each\n# resource representing 1/100th of a gallon\nresevoir_capacity &lt;- 15000 * 100\n\n# assume we are starting with a full reservoir\ncurrent_capacity &lt;- resevoir_capacity\n\nsim_time &lt;- 4 * 7 * 24 * 60 # 4 weeks in minutes\nreplications &lt;- 25",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#trajectories",
    "href": "recitations/R8_nb.html#trajectories",
    "title": "#8 Gas Station Template",
    "section": "4.1 Trajectories",
    "text": "4.1 Trajectories\n\nHelper Functions\nNote that there are many things we must define before we can use them. For instance right here, I define a function which will return either 0 or 1 and will be used in a subsequent trajectory branch.\n\nshould_I_leave &lt;- function() {\n  # by default, the cars should continue, which happens if this function\n  # returns 0\n  select_traj &lt;- 0\n  # get then number of cars in the system\n  # facility has Inf \n  total_cars &lt;- get_server_count(env, \"facility\")\n  \n  # simulate whether this car will leave or not\n  if(total_cars &gt;= too_many_cars) {\n    if(runif(1) &lt;= p_leave_too_many) {\n      # if there are too many cars and this person decides to leave,\n      # we return a value of 1 so that the \"branch\" will select the first\n      # (and only) sub-trajectory\n      select_traj &lt;- 1\n    }\n  }\n  return(select_traj)\n}\n\n\n\nCar Trajectory\nNow the car trajectory has more going on than we’ve seen thus far. It shows up and takes one (of infinite) facility servers and then decides if it should stay or go. This is done with the branch function. should_I_leave() returns either 0 or 1. If it returns 0, it skips the sub-trajectory defined within this branch. If it returns 1, it follows the first (and only) trajectory in the branch. If there were other possible options, should_I_leave would just need to return an integer value which would direct the car to the corresponding sub-trajectory in this branch. Next it uses one attendant for the random amount of time sampled from initiate_service and then seizes the gas that it wants. “gas” is defined as a resource with queue_size=0. This makes it so that if there isn’t enough gas, there is an unsuccessful seize and the car leaves with the service completion flag set to FALSE. If queue_size \\(\\neq\\) 0, then cars could line up endlessly while the gas station itself is literally out of gas. This is different than lining up waiting to be served gas. I set the amount of gas I want with set_attribute(\"demand\", gal_gas) which provides a locally scoped (i.e. only available to each car) key, value pair. That value is then retrieved with get_attribute(\"demand\"). I need to do this so that in the first place I can specify how much to seize and in the second I can determine how long it should take. It times out on the amount of gas divided by the fuel pump rate (but again divided by 100 so that 1/100th gal of gas is now 1 unit of “gas”). Finally the car visits the attendant again for some random amount of time sampled this time from finalize_service and the facility is released. Note that “gas” is never released. This helps us keep track of how much gas is in the resevoir.\n\ncar_traj &lt;- trajectory() |&gt;\n  seize(\"facility\", 1) |&gt;\n  branch(\n    function() should_I_leave(),\n    # option is a callable object\n    # if it takes value 0, the car might renege\n    continue = c(FALSE),\n    trajectory() |&gt;\n      log_(\"Too many cars!\") |&gt;\n      renege_in(0)\n  ) |&gt;\n  visit(\"attendant\", initiate_service) |&gt;\n  set_attribute(\"demand\", gal_gas) |&gt;\n  seize(\"gas\", function() get_attribute(env, \"demand\"),\n        # there is no queue allowed for gas. (i.e. they run out of gas)\n        # so we define a reject trajectory in case of an unsuccessful seize\n        continue = FALSE, reject = trajectory() |&gt;\n          release(\"facility\", 1) |&gt;\n          log_(\"no gas!\")\n          ) |&gt;\n  timeout(function() get_attribute(env, \"demand\") / 100 / gal_per_min) |&gt;\n  visit(\"attendant\", finalize_service) |&gt;\n  release(\"facility\", 1)    \n\n\n\nFuel Truck Trajectory\nOur next trajectory is a fuel truck with comes and performs a basic function. It increases the gas (indicated by mod = \"+\") by however much room is in the reservoir. We have to figure this out by seeing how much gas has been sold and how much total gas has come into the system.\n\nfueler_traj &lt;- trajectory() |&gt;\n  set_capacity(\"gas\",\n    # need a callable function\n    function() resevoir_capacity -\n      # difference between total gas in the system and amount sold\n      (get_capacity(env, \"gas\") - get_server_count(env, \"gas\")),\n    mod = \"+\")",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#adding-resources",
    "href": "recitations/R8_nb.html#adding-resources",
    "title": "#8 Gas Station Template",
    "section": "4.2 Adding Resources",
    "text": "4.2 Adding Resources\nWe have already instantiated the environment, so now we just add to it with the |&gt; operator. Instead of specifying a number for capacity, we submit the schedule. As mentioned above, “gas” queue size is set to 0 so that nobody can wait around for gas when there isn’t any.\n\nenv |&gt;\n  # the capacity changes throughout the day according to the crew schedule\n  add_resource(\"attendant\", capacity = crew_schedule) |&gt;\n  \n  # this is a place holder to show where/how we will add real estate resources\n  add_resource(\"facility\", capacity = station_schedule) |&gt;\n  \n  # setting queue size to 0 so that when it runs out of gas, customers leave\n  add_resource(\"gas\", current_capacity, queue_size = 0)\n\nsimmer environment: anonymous | now: 0 | next: 420\n{ Monitor: in memory }\n{ Resource: attendant | monitored: TRUE | server status: 0(0) | queue status: 0(Inf) }\n{ Resource: facility | monitored: TRUE | server status: 0(0) | queue status: 0(Inf) }\n{ Resource: gas | monitored: TRUE | server status: 0(1500000) | queue status: 0(0) }",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#adding-generators",
    "href": "recitations/R8_nb.html#adding-generators",
    "title": "#8 Gas Station Template",
    "section": "4.3 Adding Generators",
    "text": "4.3 Adding Generators\nNow we have two things that should appear in our system. The cars which arrive from when it opens until 15-minutes before it closes and a fuel truck which will perform the functions in its trajectory.\n\nenv |&gt; \n  add_generator(\"car\", car_traj,\n                # assume we don't let anybody in after 6:45 PM\n                from_to(start_time = 7*60, stop_time = 18.75*60,\n                        # they arrive at the constant rate\n                        dist = car_interarrival,\n                        # they do it every day\n                        every = 24*60)) |&gt;\n  # this will fill up the reservoir every 4 days\n  add_generator(\"fueler\", fueler_traj, function() 4*24*60)\n\nsimmer environment: anonymous | now: 0 | next: 0\n{ Monitor: in memory }\n{ Resource: attendant | monitored: TRUE | server status: 0(0) | queue status: 0(Inf) }\n{ Resource: facility | monitored: TRUE | server status: 0(0) | queue status: 0(Inf) }\n{ Resource: gas | monitored: TRUE | server status: 0(1500000) | queue status: 0(0) }\n{ Source: car | monitored: 1 | n_generated: 0 }\n{ Source: fueler | monitored: 1 | n_generated: 0 }",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "recitations/R8_nb.html#running-model-and-extracting-results",
    "href": "recitations/R8_nb.html#running-model-and-extracting-results",
    "title": "#8 Gas Station Template",
    "section": "4.4 Running Model and Extracting Results",
    "text": "4.4 Running Model and Extracting Results\nThe snippet below will run the model for sim_time length. The point of this model is to consider how the “gas” amount changes over the days. It is not a complete reset every day. That is why it is run for 4-weeks (in minutes). Eventually we will want to replicate this 4-week simulation twenty-five times.\n\nreset(env) |&gt; run(sim_time)\n\n1034.87: car226: Too many cars!\n\n\nsimmer environment: anonymous | now: 40320 | next: 40320\n{ Monitor: in memory }\n{ Resource: attendant | monitored: TRUE | server status: 0(0) | queue status: 0(Inf) }\n{ Resource: facility | monitored: TRUE | server status: 0(0) | queue status: 0(Inf) }\n{ Resource: gas | monitored: TRUE | server status: 6879212(7383573) | queue status: 0(0) }\n{ Source: car | monitored: 1 | n_generated: 6779 }\n{ Source: fueler | monitored: 1 | n_generated: 7 }\n\n\nWe extract the results as usual. Below I just perform a couple of basic post-processing tasks as you would with any table.\n\narrivals &lt;- get_mon_arrivals(env)\nresources &lt;- get_mon_resources(env)\narrivals$system_time &lt;- arrivals$end_time - arrivals$start_time\n\nresources$gas_resevoir &lt;- NaN\n\nresources[resources == \"gas\", 'gas_resevoir'] &lt;- resources[resources == \"gas\", 'capacity'] - resources[resources == \"gas\", 'server']\n\n\nkable(head(arrivals))\n\n\n\nTable 1: First few arrivals rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nname\nstart_time\nend_time\nactivity_time\nfinished\nreplication\nsystem_time\n\n\n\n\ncar0\n420.0000\n424.0057\n4.005686\nTRUE\n1\n4.005686\n\n\ncar2\n420.8825\n425.2802\n4.397746\nTRUE\n1\n4.397746\n\n\ncar1\n420.6360\n426.2980\n5.662055\nTRUE\n1\n5.662055\n\n\ncar3\n425.0393\n430.5381\n5.257861\nTRUE\n1\n5.498807\n\n\ncar4\n429.0033\n433.3824\n4.379141\nTRUE\n1\n4.379141\n\n\ncar5\n429.7669\n433.6865\n3.635647\nTRUE\n1\n3.919592\n\n\n\n\n\n\n\n\n\nkable(head(resources))\n\n\n\nTable 2: First few resource rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nresource\ntime\nserver\nqueue\ncapacity\nqueue_size\nsystem\nlimit\nreplication\ngas_resevoir\n\n\n\n\nattendant\n0\n0\n0\n0\nInf\n0\nInf\n1\nNaN\n\n\nfacility\n0\n0\n0\n0\nInf\n0\nInf\n1\nNaN\n\n\nattendant\n420\n0\n0\n2\nInf\n0\nInf\n1\nNaN\n\n\nfacility\n420\n0\n0\nInf\nInf\n0\nInf\n1\nNaN\n\n\nfacility\n420\n1\n0\nInf\nInf\n1\nInf\n1\nNaN\n\n\nattendant\n420\n1\n0\n2\nInf\n1\nInf\n1\nNaN\n\n\n\n\n\n\n\n\n\nresources[resources == \"gas\", ] |&gt; ggplot(aes(x = time, y =gas_resevoir)) +\n  geom_line()\n\n\n\n\n\n\n\nFigure 1: Resvoir Amount over Time\n\n\n\n\n\n\nplot(resources, names = \"gas\", steps = TRUE)\n\n\n\n\n\n\n\nFigure 2: Gas in the system and sold over time\n\n\n\n\n\nFinally you can easily see how the workers reflect the schedule.\n\nplot(resources, names = \"attendant\", steps = TRUE)\n\n\n\n\n\n\n\nFigure 3: Gas Attendants\n\n\n\n\n\nAnd the other methods of plotting and information are available to you as before.",
    "crumbs": [
      "Tutorials",
      "#8 Getting Started with Gas Station Modeling"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html",
    "href": "solutions/HW1_nb.html",
    "title": "HW1 Solution",
    "section": "",
    "text": "The purpose of this solution is to demonstrate how Quarto should be used to prepare future homework submissions. Additionally, this will show how simply these problems can be solved using simmer. Reports should follow the same principles with one exception. In homeworks, show all code in the cells by setting #| echo: true. In reports, hide the code with #| echo: false. Homeworks do not require extensive explanation of the process as the problems are straightforward, but I do need to see the code. Project reports, on the other hand, should emphasize the high-level modeling process, assumptions, results, and results discussion. Reports go out to many different entities in an organization and most will not want to see your code. Those that do will ask for it. The benefit of using Quarto is that you can then just send them the “.qmd” document and they can review everything.",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#approach",
    "href": "solutions/HW1_nb.html#approach",
    "title": "HW1 Solution",
    "section": "3.1 Approach",
    "text": "3.1 Approach\n\nLoad Packages\nModel the system in simmer\nRun the simulation\nExtract required statistics",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#loading-packages",
    "href": "solutions/HW1_nb.html#loading-packages",
    "title": "HW1 Solution",
    "section": "3.2 Loading Packages",
    "text": "3.2 Loading Packages\n\n# setting random seed for reproducibilty\nset.seed(1766)\n\n# for plots, data manipulation, and output\nlibrary(tidyverse)\nlibrary(knitr)\n\n# simulation package\nlibrary(simmer)\nlibrary(simmer.plot)\nlibrary(simmer.bricks)\n\n# packages for making animations\nlibrary(gganimate)\nlibrary(gifski)",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#building-simmer-model",
    "href": "solutions/HW1_nb.html#building-simmer-model",
    "title": "HW1 Solution",
    "section": "3.3 Building simmer Model",
    "text": "3.3 Building simmer Model\nFirst we will define the parameters in a way that is easy and clear to be referenced later. Then we need to define the trajectory, the resources, and the simmer environment.\n\n3.3.1 Bank Parameters\n\nbank_sim_time &lt;- c(2*60, 24*60)\n\nlambda_bank &lt;- 1/15\n\narrival_bank &lt;- function(n=1) {\n  rexp(n = n, rate = lambda_bank)\n}\n\nmu_bank &lt;- 1/12\n\nservice_bank &lt;- function(n=1) {\n  rexp(n = n, rate = mu_bank)\n}\n\n\n\n3.3.2 Customer Trajectory\n\ncustomer &lt;- trajectory(\"customer\") |&gt;\n  visit(\"teller\", service_bank)\n\n\n\n3.3.3 Bank Environment\n\nbank &lt;- simmer(\"bank\") |&gt;\n  add_resource(\"teller\") |&gt;\n  add_generator(\"customer\", customer, arrival_bank)\n\n\n\n3.3.4 Run Simulation & Save Results\n\nreset(bank) |&gt; run(bank_sim_time[1])\nbank_resources_2 &lt;- get_mon_resources(bank)\nbank_arrivals_2 &lt;- get_mon_arrivals(bank)\n\n\nreset(bank) |&gt; run(bank_sim_time[2])\n\nsimmer environment: bank | now: 1440 | next: 1455.6246555489\n{ Monitor: in memory }\n{ Resource: teller | monitored: TRUE | server status: 1(1) | queue status: 2(Inf) }\n{ Source: customer | monitored: 1 | n_generated: 103 }\n\nbank_resources_24 &lt;- get_mon_resources(bank)\nbank_arrivals_24 &lt;- get_mon_arrivals(bank)\n\n\n\n3.3.5 Extract Statistics\n\nresource_weighted_avg &lt;- function(resource_data, item, sim_time) {\n  resource_data &lt;- resource_data |&gt;\n    arrange(time) |&gt;\n    mutate(time_diff = lead(time, default = sim_time) - time)\n  \n  return(sum(resource_data[[item]] * resource_data$time_diff) / sim_time)\n}\n\n\nL_bank_2hr &lt;- resource_weighted_avg(\n  bank_resources_2, \"system\", bank_sim_time[1])\n\nL_bank_24hr &lt;- resource_weighted_avg(\n  bank_resources_2, \"system\", bank_sim_time[2])\n\n\nW_bank_2hr &lt;- mean(bank_arrivals_2$end_time - bank_arrivals_2$start_time)\n\nW_bank_24hr &lt;- mean(bank_arrivals_24$end_time - bank_arrivals_24$start_time)\n\nThe results are summarized in Table 1\n\nbank_summary_df &lt;- tibble(\n  \"Simulation Time (min)\" = bank_sim_time,\n  \n  \"Avg Customers in System, L\" = round(\n    c(L_bank_2hr, L_bank_24hr), digits = 2),\n  \n  \"Avg Time in System, W (min)\" = round(\n    c(W_bank_2hr, W_bank_24hr), digits = 2)\n)\n\nkable(bank_summary_df)\n\n\n\nTable 1: Bank Simulation Summary Table\n\n\n\n\n\n\n\n\n\n\n\nSimulation Time (min)\nAvg Customers in System, L\nAvg Time in System, W (min)\n\n\n\n\n120\n0.91\n22.94\n\n\n1440\n2.83\n47.46\n\n\n\n\n\n\n\n\n\n\n3.3.6 Plot\nSee Figure 1 and Figure 3 for static plots.\n\nplot(bank_resources_2, items = \"system\") +\n  labs(\n    x = \"time (min)\",\n    y = \"customers\",\n    title = \"average over time\"\n  )\n\n\n\n\n\n\n\nFigure 1: Bank System (2 hr)\n\n\n\n\n\n\nplot(bank_resources_2, items = \"system\", steps = TRUE) +\n  labs(\n    x = \"time (min)\",\n    y = \"customers\",\n    title = \"instantaneous\"\n  )\n\n\n\n\n\n\n\nFigure 2: Bank System (2 hr)\n\n\n\n\n\n\nplot(bank_resources_24, items = \"system\") +\n  labs(\n    x = \"time (min)\",\n    y = \"customers\",\n    title = \"average over time\"\n  )\n\n\n\n\n\n\n\nFigure 3: Bank System (24 hr)\n\n\n\n\n\n\nplot(bank_resources_24, items = \"system\", steps = TRUE) +\n  labs(\n    x = \"time (min)\",\n    y = \"customers\",\n    title = \"instantaneous\"\n  )\n\n\n\n\n\n\n\nFigure 4: Bank System (24 hr)\n\n\n\n\n\n\n\n3.3.7 Animation\nWe are tasked with animating the average number of customers in the system. This means we do not want the step-plot which gives the instantaneous number of people in the system. We have already generated this static plot in Figure 1. simmer.plot already handled getting the time-weighted average. All we need to do is animate it which is shown and explained in the code below.\n\n\n\n\n\n\nNote\n\n\n\nAs I’ve pointed out before, you cannot insert a “.gif” into a pdf. You need to set the cell eval option to false as shown below. Run the cell by clicking the “Run Current Chunk” in RStudio.\n\n\n\n```{r, animate-2hr-average}\n#| eval: false\n#| warning: false\n\n1p &lt;- plot(bank_resources_2, \"teller\", metric=\"usage\", item=\"system\") +\n2    labs(\n      x=\"Time (min)\",\n      y=\"Number Customers\"\n    ) +\n3  transition_reveal(bank_resources_2$time)\n\n4anim_save(\"bank_2hr_anim.gif\", p)\n```\n\n\n1\n\nAssign our plot to a variable\n\n2\n\nAdjust x and y label\n\n3\n\nSpecify what part of the plot should be animated\n\n4\n\nSave the animation.\n\n\n\n\n\n\n\n\n\n\nFigure 5: Animation of Average Customers in the bank",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#tollbooth-parameters",
    "href": "solutions/HW1_nb.html#tollbooth-parameters",
    "title": "HW1 Solution",
    "section": "4.1 Tollbooth Parameters",
    "text": "4.1 Tollbooth Parameters\nThe given parameters of the problem are defined below:\n\ntoll_sim_time &lt;- c(2*60, 24*60)\n\nlambda_toll &lt;- 1/4\n\narrival_toll &lt;- function(n=1) {\n  rexp(n=n, 1/lambda_toll)\n}\n\nmu_toll &lt;- 10/60\n\nservice_toll &lt;- function(n=1) {\n  rexp(n=n, 1/mu_toll)\n}",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#tollbooth-simmer",
    "href": "solutions/HW1_nb.html#tollbooth-simmer",
    "title": "HW1 Solution",
    "section": "4.2 Tollbooth Simmer",
    "text": "4.2 Tollbooth Simmer\nWe create our simmer model by creating a trajectory, a simmer environment, adding a resource, and adding a the trajectory.\n\nvehicle_traj &lt;- trajectory() |&gt;\n  visit(\"tollbooth\", service_toll)\n\ntollbooth &lt;- simmer() |&gt;\n  add_resource(\"tollbooth\") |&gt;\n  add_generator(\"vehicle\", vehicle_traj, arrival_toll)",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#tollbooth-results",
    "href": "solutions/HW1_nb.html#tollbooth-results",
    "title": "HW1 Solution",
    "section": "4.3 Tollbooth Results",
    "text": "4.3 Tollbooth Results\nExtract results using get_mon_arrivals and get_mon_resources which stands for get monitored arrivals and resources, respectively. This goes into the simulated environment and pulls out the data we need into tables which we can easily access.\n\n# first reset the model, then run it for 2*60\nreset(tollbooth) |&gt; run(toll_sim_time[1])\n# extract results\ntollbooth_arrivals_2hr &lt;- get_mon_arrivals(tollbooth)\ntollbooth_resources_2hr &lt;- get_mon_resources(tollbooth)\n\n# repeat\nreset(tollbooth) |&gt; run(toll_sim_time[2])\ntollbooth_arrivals_24hr &lt;- get_mon_arrivals(tollbooth)\ntollbooth_resources_24hr &lt;- get_mon_resources(tollbooth)\n\nNow we calculate the weighted average for the number of vehicles in the system, the total time in the system, and the time waiting in the queue for both simulations.\n\n# reusing the function written above to get the time-weighted average\nL_booth_2hr &lt;- resource_weighted_avg(\n  tollbooth_resources_2hr, \"system\", toll_sim_time[[1]])\n\n# creating a column which calculates the time in the system for each vehicle\ntollbooth_arrivals_2hr$system_time &lt;-tollbooth_arrivals_2hr$end_time -\n  tollbooth_arrivals_2hr$start_time\n\n# averaging this column\nW_booth_2hr &lt;- mean(tollbooth_arrivals_2hr$system_time)\n\ntollbooth_arrivals_2hr$q_time &lt;- tollbooth_arrivals_2hr$system_time -\n  tollbooth_arrivals_2hr$activity_time\n\nWq_booth_2hr &lt;- mean(tollbooth_arrivals_2hr$q_time)\n\nWe repeat the process for getting the stats for the 24-hour simulation.\n\n# repeating for 24 hr sim\nL_booth_24hr &lt;- resource_weighted_avg(\n  tollbooth_resources_24hr, \"system\", toll_sim_time[[2]])\n\ntollbooth_arrivals_24hr$system_time &lt;-tollbooth_arrivals_24hr$end_time -\n  tollbooth_arrivals_24hr$start_time\n\n\nW_booth_24hr &lt;- mean(tollbooth_arrivals_24hr$system_time)\n\ntollbooth_arrivals_24hr$q_time &lt;- tollbooth_arrivals_24hr$system_time -\n  tollbooth_arrivals_24hr$activity_time\n\nWq_booth_24hr &lt;- mean(tollbooth_arrivals_24hr$q_time)\n\nThe results are summarized in Table 2.\n\ntollboth_summary_df &lt;- tibble(\n  \"Simulation Time (min)\" = toll_sim_time,\n  \n  \"Avg Vehicles in System, L\" = round(\n    c(L_booth_2hr, L_booth_24hr), digits = 2),\n  \n  \"Avg Time in System, W (min)\" = round(\n    c(W_booth_2hr, W_booth_24hr), digits = 2),\n  \n  \"Avg Waiting Time, W_q (min)\" = round(\n    c(Wq_booth_2hr, Wq_booth_24hr), digits = 2)\n)\n\nkable(tollboth_summary_df)\n\n\n\nTable 2: tollbooth Simulation Summary Table\n\n\n\n\n\n\n\n\n\n\n\n\nSimulation Time (min)\nAvg Vehicles in System, L\nAvg Time in System, W (min)\nAvg Waiting Time, W_q (min)\n\n\n\n\n120\n1.89\n0.49\n0.31\n\n\n1440\n1.90\n0.48\n0.31",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/HW1_nb.html#animation-1",
    "href": "solutions/HW1_nb.html#animation-1",
    "title": "HW1 Solution",
    "section": "4.4 Animation",
    "text": "4.4 Animation\nWe follow the exact same process as before. We just change the variables we are referencing and the names (“clerk” becomes “tollbooth”, the y-label becomes “Number Vehicles”, the filename becomes “tollbooth_2hr_anim.gif”)\n\np &lt;- plot(tollbooth_resources_2hr,\n          \"tollbooth\", metric=\"usage\", item=\"system\") +\n    labs(\n      x=\"Time (min)\",\n      y=\"Number Vehicles\"\n    ) +\n  transition_reveal(tollbooth_resources_2hr$time)\n\nanim_save(\"tollbooth_2hr_anim.gif\", p)\n\n\n\n\n\n\n\nFigure 6: Animation of Average Vechiels at tollbooth",
    "crumbs": [
      "Homework Solutions",
      "Homework 1"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html",
    "href": "solutions/hw2_nb.html",
    "title": "HW2 Solution",
    "section": "",
    "text": "A manager is interested in purchasing a new cooling system for a reactor if it can meet a system reliability goal of 95% reliable over 1.5 years. The system information is as follows:\nA cooling system for a reactor has three identical cooling loops. Each cooling loop has two identical pumps connected in series. The cooling system requires that at least 2 of the 3 cooling loops operate successfully.\nA two-component series system works if both components work. The series system fails if any one of the system components fails.\nThe lifetimes (in years) of the pump follows an exponential distribution where a sample of historical failure of the pump data from the manufacturer is as follows:\n\n\n\nTable 1: Pump Failure Time Data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n34.3\n13.9\n22.9\n22.5\n23.6\n23.9\n25.6\n27.5\n22.7\n24.7\n25.4\n27.4\n\n\n22.5\n12.8\n15.8\n33.4\n24.9\n21.9\n25.8\n23.4\n15.8\n21.5\n28.3\n25.4",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#fit-data",
    "href": "solutions/hw2_nb.html#fit-data",
    "title": "HW2 Solution",
    "section": "1.1 Fit Data",
    "text": "1.1 Fit Data\nFirst we load our packages.\n\nlibrary(tidyverse)      # for plotting and data. manipulation\nlibrary(fitdistrplus)   # for fitting dist to data\nlibrary(knitr)          # for outputting nice tables\nlibrary(gganimate)\nlibrary(gifski)\nset.seed(1766)\n\nNext we need to fit the specified distribution to the provided data:\n\nfailure_data &lt;- c(\n  34.3, 13.9, 22.9, 22.5, 23.6, 23.9, 25.6, 27.5, 22.7, 24.7, 25.4, 27.4,\n  22.5, 12.8, 15.8, 33.4, 24.9, 21.9, 25.8, 23.4, 15.8, 21.5, 28.3, 25.4\n)\n\nfexp &lt;- fitdist(failure_data, \"exp\")\n\nNow we can define our distribution that we will sample from:\n\npump_ft &lt;- function(n=1) {\n  rexp(n=n, fexp$estimate[\"rate\"])\n}",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#simulate-failures",
    "href": "solutions/hw2_nb.html#simulate-failures",
    "title": "HW2 Solution",
    "section": "1.2 Simulate Failures",
    "text": "1.2 Simulate Failures\n\nreplicas &lt;- 25\n\nsim_data &lt;- tibble(\n  A1 = pump_ft(replicas),\n  A2 = pump_ft(replicas),\n  B1 = pump_ft(replicas),\n  B2 = pump_ft(replicas),\n  C1 = pump_ft(replicas),\n  C2 = pump_ft(replicas),\n)",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#determine-system-failure-time",
    "href": "solutions/hw2_nb.html#determine-system-failure-time",
    "title": "HW2 Solution",
    "section": "1.3 Determine System Failure Time",
    "text": "1.3 Determine System Failure Time\nFirst we determine the failure time of each subsystem by taking the minimum failure time of each of the two pumps. We do this with pmin which compares the elements of each column against each other as shown. If we only used min, this would look for the minimum of all values in the columns which would be the shortest failure time of any of the replicas for those two pumps.\n\nsim_data &lt;- sim_data |&gt; mutate(\n  A = pmin(A1, A2),\n  B = pmin(B1, B2),\n  C = pmin(C1, C2),\n)\n\nNext we put the three subsystem failure times into a vector and sort them so that we can select the second smallest value. Since there are only three subsystems, this is the same as selecting the second largest. For good practice, it is important to be intentional and explicit about which way things are sorted if you are going to extract a certain ordered value. Here I set decreasing = FALSE knowing that the first subsystem fails at sorted_vals[1] and the second subsystem fails at sorted_vals[2].\n\nsim_data &lt;- sim_data |&gt; mutate(\n    SystemFailureTime = apply(sim_data[, 7:9], 1, function(row) {\n      # sort the values from \n      sorted_vals &lt;- sort(row, decreasing = FALSE)\n      # select the second largest\n      sorted_vals[2]\n    })\n  )",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#obtain-empirical-reliability-funciton",
    "href": "solutions/hw2_nb.html#obtain-empirical-reliability-funciton",
    "title": "HW2 Solution",
    "section": "1.4 Obtain Empirical Reliability Funciton",
    "text": "1.4 Obtain Empirical Reliability Funciton\nUse the ecdf function to create an empirical cumulative distriution function, \\(F(t)\\) for our system failure times. This represents the probability that the system has failed at a given time, but we want the probability that it is working. This is simply \\(R(t) = 1 - F(t)\\).\n\nF &lt;- ecdf(sim_data$SystemFailureTime)\n\nR_sim &lt;- function(t) {1 - F(t)}",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#solutions",
    "href": "solutions/hw2_nb.html#solutions",
    "title": "HW2 Solution",
    "section": "1.5 Solutions",
    "text": "1.5 Solutions\n\n1.5.1 Reliability at 5, 10, 12 years\nThe relibability for the specified years are given in Table 2 below.\n\nR_mission &lt;- tibble(\n  Year = c(5, 10, 12),\n  Simulated = R_sim(Year)\n)\n\nkable(R_mission, digits=2)\n\n\n\nTable 2: Reliability at Specified Years\n\n\n\n\n\n\nYear\nSimulated\n\n\n\n\n5\n0.76\n\n\n10\n0.32\n\n\n12\n0.20\n\n\n\n\n\n\n\n\n\n\n1.5.2 Expected Cooling System Lifetime\nOne valid method to calculate the expected lifetime of the system is to average the system failure times from the simulations.\n\nmean_life_system_sim &lt;- mean(sim_data$SystemFailureTime)\n\nThe expected lifetime is 10.057 years.\nAnother valid way is using the \\(R(t)\\) function we made. See the solution in Part II for further details. Essentially, this is discretizing the ecdf and multiplying the probability of taking a given value times that value.\n\n# determine discretization amount\ndx = 0.01\n\n# determine maximum life from simulation. R(t &gt; L) = 0 so no need to go beyond\nL = quantile(F, 1)\n\nmean_life_system_sim_ecdf &lt;- sum(R_sim(seq(0, L, length.out=L/dx))) * dx\n\nThe expected lifetime using the ecdf is 10.061 years.\n\n\n1.5.3 Animation\nDetermine how far out we need to animate. We can do this by looking at the data and seeing the maximum lifetime of the system or we could see at what point 100% of the failures occur from the empirical cumulative distribution function, F. Either way, we get around 25 (depending on the results of a given set of simulations). I’ll plot until 35 Figure 1 gives a static plot.\nFirst we can generate a static plot for inclusion in the pdf.\n\nhorizon &lt;- seq(0, 50)\n\nR_tbl &lt;- tibble(\n  Time = horizon,\n  Reliability = R_sim(Time),\n  Method = \"Simulated\"\n)\n\np &lt;- R_tbl |&gt; ggplot(aes(x=Time, y=Reliability, group=\"Method\")) +\n  geom_line() +\n  labs(\n    title = \"Empirical Reliability\",\n    x = \"Time (years)\"\n  )\n\np\n\n\n\n\n\n\n\nFigure 1: Empirical Reliability Pot\n\n\n\n\n\n\n\n1.5.4 Show Simulation Results\nNow we can animate this plot and save it to our computer by simply adding a transition_reveal element to the plot. Note that eval is set to false so that it isn’t executed when the file is rendered.\n\n```{r, show-results}\n#| eval: false\n\np &lt;- p +\n  transition_reveal(Time)\n\nanim_save(\"pump_reliability_anim.gif\", p)\n```\n\n\n\n\n\n\n\nFigure 2: Animation of System Reliability over Time",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#algebraic-system-reliability-expression",
    "href": "solutions/hw2_nb.html#algebraic-system-reliability-expression",
    "title": "HW2 Solution",
    "section": "2.1 Algebraic System Reliability Expression",
    "text": "2.1 Algebraic System Reliability Expression\nWe need to write an algebraic expression of the system reliability as a function of the individual pump failure times in order to answer these questions. There are a number of ways to do this. For this particular system which fails when the second sub-system fails, I think the easiest way is to write out a boolean table.\nFirst, let the probability that a single pump is working at a given time be \\(p\\). Later, we will substitute in an expression for the reliability of the pump as a function of time. We will write out a table which shows every possibility where the system is working. We will determine the probability of that scenario occuring, and then sum all those probabilities. This will give us the probability the system is working.\nFirst, I’ll write out the first few rows in Table 3 and discuss them.\n\n\n\nTable 3: Initial Boolean Table\n\n\n\n\n\nn\nA1\nA2\nB1\nB2\nC1\nC2\n\n\n\n\n1\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\n\n2\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\n\n3\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(p\\)\n\n\n4\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(1-p\\)\n\n\n\n\n\n\nThe first rows represents the possibility that all pumps are functioning. Obviously the system is functioning when that is the case. The next three rows represent the ways that pumps from subsystem C can fail while the system still operates. C2 could fail (row 2), just C1 could fail (row 3) or both could fail (row 4). Rows 2 to 4 repeat themselves shifting the failures to system B while C works and then to A while both B and C work as shown in Table 4.\n\n\n\n\nTable 4: Complete Boolean Table\n\n\n\n\n\nn\nA1\nA2\nB1\nB2\nC1\nC2\n\n\n\n\n1\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\n\n2\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\n\n3\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(p\\)\n\n\n4\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(1-p\\)\n\n\n5\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(p\\)\n\\(p\\)\n\n\n6\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\n\n7\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(1-p\\)\n\\(p\\)\n\\(p\\)\n\n\n8\n\\(p\\)\n\\(1-p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\n\n9\n\\(1-p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\n\n10\n\\(1-p\\)\n\\(1-p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\n\n\n\n\n\n\n2.1.1 Conditional Probability Review\nNow we can determine the probability of each scenario occuring. Consider the question of what is the probability of rolling five dice all with the value of 3. We are familiar with this as conditional probability and is solved by multiplying the probabilities together. Let \\(X\\) represent the random outcome from a single dice roll.\n\\[\nP(X = k) = \\frac{1}{6},\\ k \\in \\left\\{ 1, 2, 3, 4, 5, 6 \\right\\}\n\\tag{1}\\]\nThe probability of any roll is the same at \\(\\frac{1}{6}\\). The probability of each dice rolling a specific number (i.e. all dice roll 3, or dice 1 rolls 1, dice 2 rolls 2, etc.) is given as:\n\\[\nP = \\prod_{i=1}^5(P(X_i=3)) = \\frac{1}{6} \\frac{1}{6} \\frac{1}{6} \\frac{1}{6} \\frac{1}{6} = \\frac{1}{6^5} = \\frac{1}{7776} \\approx 0.000128 \\approx 0.0128\\%\n\\tag{2}\\]\n\n\n2.1.2 Applying Conditional Probability\nWe can apply that conditional probability to each scenario from the boolean table. Again I’ll do the first few rows and discuss.\n\n\n\nTable 5: Initial Boolean Table with System Probability\n\n\n\n\n\nn\nA1\nA2\nB1\nB2\nC1\nC2\nSystem is Functioning\n\n\n\n\n1\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p^6\\)\n\n\n2\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(p^5 (1-p)\\)\n\n\n3\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(p\\)\n\\(p^5 (1-p)\\)\n\n\n4\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(p\\)\n\\(1-p\\)\n\\(1-p\\)\n\\(p^4 (1-p) (1-p)\\)\n\n\n\n\n\n\nSome things to note to simplify our work. Rows 2 to 4 will repeat themselves two more times for the case when B has failure(s) but A & C are functioning and where A has failure(s) but B and C are still functioning. We can now express the total system reliability as a function of \\(p\\) by summing the last column. I omit repeating scenarios 5-7 and 8-10 as I’ve already stated we can just multiply the sum of rows 2-4 by 3 as shown below.\n\\[\np_{sys} = p^6 + 3\\left((p^5 (1-p)) + (p^5 (1-p)) + (p^4 (1-p)^2)\\right)\n\\tag{3}\\]\n\n\n2.1.3 Substitute Pump Reliability Expression\nWe can now substitute in for \\(p\\) an expression of the pump reliability at a given time. We have that the failure distribution of the pump is:\n\\[\nf_{pump}(t) = \\lambda\\exp(-\\lambda t)\n\\tag{4}\\]\nThis is a common distribution with a known cumulative distribution as given below:\n\\[\nF_{pump}(t) = 1 - \\exp(- \\lambda t)\n\\tag{5}\\]\nIf we didn’t have this, we could have integrated the pdf (\\(f(t)\\)) and solved for constants of integration knowing that \\(F(0) = 0\\).\nEquation 5 represents the probability that a pump isn’t working. We want the probability that it is. We get this with:\n\\[\nR_{pump}(t) = 1 - F_{pump}(t) = 1 - (1 - \\exp(- \\lambda t)) = \\exp(- \\lambda t)\n\\tag{6}\\]\nFinally, we can subsitute Equation 6 for \\(p\\) in Equation 3. Before we do this, it will make things easier to simplify the expression.\n\\[\np_{sys} = -2p^6 + 3p^4\n\\tag{7}\\]\n\n\n2.1.4 Obtaining System Reliability Expression\nSubstituting \\(R_{pump}(t)\\) for \\(p\\):\n\\[\nR_{sys}(t) = -2 (\\exp(- \\lambda t))^6 + 3 (\\exp(- \\lambda t))^4 \\\\\n\\] \\[\n= -2 \\exp(-6 \\lambda t) + 3 \\exp(-4 \\lambda t)\n\\]\nWe still rely on estimated value for \\(\\lambda\\) from our fexp. We can now write a complete R function which expresses the analytical system reliability as a function of the estimated pump failure time.\n\nlambda &lt;- fexp$estimate[\"rate\"]\n\nR_analytical &lt;- function(t) {\n  -2 * exp(-6 * lambda * t) + 3 * exp(-4 * lambda * t)\n}",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  },
  {
    "objectID": "solutions/hw2_nb.html#solutions-to-questions",
    "href": "solutions/hw2_nb.html#solutions-to-questions",
    "title": "HW2 Solution",
    "section": "2.2 Solutions to Questions",
    "text": "2.2 Solutions to Questions\n\n2.2.1 Reliability at Specified Times\nWe can apply our analytical reliabiity function to the table below the same as we did the empirically-based method.\n\n# adding an analytical column and evaluate `R_analytical` on the `Year` col\nR_mission &lt;- R_mission |&gt; mutate(\n  Analytical = R_analytical(Year)\n)\n\n# only want to look at the Analytical solutions right now\nkable(R_mission[, c(\"Year\", \"Analytical\")], digits=2)\n\n\n\nTable 6: Analytical Reliability at Specified Years\n\n\n\n\n\n\nYear\nAnalytical\n\n\n\n\n5\n0.72\n\n\n10\n0.39\n\n\n12\n0.30\n\n\n\n\n\n\n\n\n\n\n2.2.2 Expected Cooling System Lifetime\nThe expected value of a discrete distribution is the sum of the product of the values the distriubtion can take and the probability it takes that value. Let \\(X\\) represent a distribution which can take values from the discrete set, \\(K\\).\n\\[\nE[X] = \\sum_{k \\in K} \\left(k \\times  P(X=k) \\right)\n\\tag{8}\\]\nThe continous version of this is achieved by integrating \\(x \\times f(x)\\) over all possible values:\n\\[\nE[X] = \\int_{-\\infty}^\\infty x f(x) dx\n\\tag{9}\\]\nIntegrating by parts leaves us with the result that \\(E[X] = \\int_{-\\infty}^{\\infty} R(t)dt\\).\nApplying that to our system reliability expression, we first want to obtain the indefinite integral of \\(R(t)\\). Rather than take the integral of the sum, sum the integrals:\n\\[\n\\int R(t) dt = \\int \\left(-2 \\exp(-6 \\lambda t) + 3 \\exp(-4 \\lambda t)  \\right) dt = \\int-2 \\exp(-6 \\lambda t) dt + \\int 3 \\exp(-4 \\lambda t) dt\n\\tag{10}\\]\nApply that \\(\\int e^{cx} dx = \\frac{1}{c} e^{cx}\\)\n\\[\n\\int R(t) dt = \\frac{-2}{-6\\lambda}e^{-6\\lambda t} + \\frac{3}{-4\\lambda} e^{-4\\lambda t} + C\n\\tag{11}\\]\nWe can drop the constant of integration as we will be taking the definite integral from \\(-\\infty\\) to \\(\\infty\\). However, since we are dealing with time to failure and time cannot take a negative value, we will integrate from \\(0\\) to \\(\\infty\\).\n\\[\nE[X] = \\left[ \\frac{1}{3\\lambda}e^{-6\\lambda t} - \\frac{3}{4\\lambda} e^{-4\\lambda t} \\right]_0^\\infty = [0] - \\left[\\frac{1}{3\\lambda} - \\frac{3}{4\\lambda}\\right] = \\frac{5}{12\\lambda}\n\\tag{12}\\]\n\nmean_life_system_analytical &lt;- 5 / (12 * lambda)\n\nThe expected life of the system is 9.82 years.\n\n\n2.2.3 Results Comparison\nA comparison of the simulation and analytical based reliabilities for the specified missions is given below in Table 7.\n\nkable(R_mission, digits=2)\n\n\n\nTable 7: Specified Mission Reliability Comparison\n\n\n\n\n\n\nYear\nSimulated\nAnalytical\n\n\n\n\n5\n0.76\n0.72\n\n\n10\n0.32\n0.39\n\n\n12\n0.20\n0.30\n\n\n\n\n\n\n\n\nWe can see the simulated and analytical solutions give fairly similar results. This serves as confirmation that we implemented both methods correctly.\n\n\n2.2.4 Recommendation\nThe manager requires 95% Reliability at 1.5 years. The simulation shows a reliability of 1 while the analytical solution shows a reliability of 0.96. Both of these indicate that the system meets the requirements. However, it is interesting to note that in a system with apparent redundancy, the reliability of the system is actually less than the reliability of each individual pump as seen in Figure 3.\n\nR_tbl &lt;- R_tbl |&gt; bind_rows(\n  tibble(\n    Time = horizon,\n    Reliability = R_analytical(Time),\n    Method = \"Analytical\"\n  )\n)\n\nR_pump &lt;- function(t) {exp(-lambda*t)}\n\nR_plot_tbl &lt;- R_tbl |&gt; bind_rows(\n  tibble(\n    Time = horizon,\n    Reliability = R_pump(Time),\n    Method = \"Individual Pump Theoretical\"\n  )\n)\n\nrel_plot &lt;- R_plot_tbl |&gt; ggplot(aes(x=Time, y=Reliability, color=Method)) +\n  geom_line() +\n  labs(\n    x = \"Time (yrs)\",\n    y = \"Reliability\"\n  )\n\nggsave(\"reliability_plot.png\", rel_plot)\n\nrel_plot\n\n\n\n\n\n\n\nFigure 3: Simulated & Analytical System Reliability and Pump Reliability\n\n\n\n\n\nFor this reason, I would recommend not buying the system and investigating whether the pumps can be reconfigured in a way that the additional units improve the system reliability rather than detract from it.",
    "crumbs": [
      "Homework Solutions",
      "Homework 2"
    ]
  }
]